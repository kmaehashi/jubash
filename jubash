#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Jubatus Shell
# @author Kenichi Maehashi

'''
  _________         ___                                  
  \____   _|       | /             ___I_I___             
      |  |         | |             \__^ ^__/        ____ 
      |  |         | | ___    ___  __ | |          / __/ 
      |  | |-|  |-|| |/   \  /   \| | | | |^|  |^|| (__  
      |  | | |  | ||    ^  ||  ^    | | | | |  | | \__ \ 
      |  | | \_/  ||    O   || O    | | |_| \_/  | ___) |
      |  |  \__/|_||_|\___/  \___/|_| |__/ \__/|_| \___/ 
      | /                                                
     / /                                                 
    |/                                                   
'''
 
import sys
import cmd, readline
import argparse
import re
import json
import msgpackrpc

class JubaShell(cmd.Cmd, object):
    """
    Base class of Jubatus shell
    """
    def __init__(self, host, port, cluster, verbose_mode=False):
        cmd.Cmd.__init__(self)

        # Server configuration
        self.host = host
        self.port = port
        self.cluster = cluster

        # Shell configuration
        self.verbose_mode = verbose_mode
        # TODO: support history management

        # Help configuration
        self.doc_header = "Commands:"
        self.undoc_header = "Commands (no help available):"
        self.misc_header = "Documents:"
        self.nohelp = "No help available for %s."

        # Register aliases
        self.register_alias('EOF', 'exit')
        self.register_alias('ls', 'help')

    def engine_name(self):
        """
        Return the name of the engine (e.g., `classifier`).
        You must override this in subclasses.
        """
        raise NotImplementedError

    def start(self, oneshot=None):
        """
        Start the interactive shell.
        """
        while True:
            try:
                if not self.is_connected():
                    self.connect(self.host, self.port, self.cluster)
                if oneshot:
                    self.onecmd(oneshot)
                else:
                    self.cmdloop()
                self.disconnect()
                return
            except ValueError as e:
                print "Invalid argument: %s; use `help` command for details" % str(e.message)
                continue
            except msgpackrpc.error.RPCError as e:
                print "RPC Error: " + str(e.message)
                self.disconnect()
            except KeyboardInterrupt: # trap Ctrl-C
                print
                self.disconnect()
            finally:
                if oneshot:
                    return

    def register_alias(self, alias, name):
        """
        Register alias function to the existing function.
        Aliases are not listed by `help` command.
        """
        self.__dict__['do_' + alias] = getattr(self, 'do_' + name)

    def emptyline(self):
        """
        By default, empty line causes the previous command to run again.
        This overrides the default handler for emptyline so it behaves like the usual shell.
        """
        pass

    def default(self, line):
        print "Unknown command: %s" % line
        print "Type `help` for commands available."

    def argv2datum(self, argv):
        if len(argv) % 2 != 0:
            raise ValueError, "value for the last datum is missing"

        string_values = []
        num_values = []
        for i in range(len(argv) / 2):
            feat_key = argv[i*2]
            feat_val = argv[i*2+1]
            if self.is_num(feat_val):
                num_values.append((feat_key, float(feat_val)))
            else:
                string_values.append((feat_key, feat_val))
        return self.get_types_class('datum')(string_values, num_values)

    def computil_argnum(self, text, line, begidx, endidx):
        return len(self.argv(line[0:begidx],0)) - 1
 
    def computil_filter(self, text, candidates):
        return [x for x in candidates if x.startswith(text)]

    def verbose(self, msg):
        if self.verbose_mode:
            print msg

    #################################################################
    # Built-in commands
    #################################################################
    def do_exit(self, argv):
        """Syntax: exit
        Exit the shell. You can also use EOF (Ctrl-D).
        """
        print
        return True

    def do_connect(self, param):
        """Syntax: connect host port [cluster]
        Connect to the specified host, port and cluster (optional).
        """
        argv = self.argv(param, 2, 3)
        host = argv[0]
        port = argv[1]
        cluster = self.cluster
        if len(argv) == 3:
            cluster = argv[2]
        print "Connecting to <%s>@%s:%d..." % (cluster, host, int(port))
        self.disconnect()
        self.connect(host, int(port), self.cluster)

    def do_reconnect(self, param):
        """Syntax: reconnect
        Reconnects to the current server.
        """
        self.disconnect()
        self.connect(self.host, self.port, self.cluster)

    def do_verbose(self, param):
        """Syntax: verbose
        Toggles the verbose mode.
        """
        self.verbose_mode = not self.verbose_mode
        if self.verbose_mode:
            print "Verbose mode turned on."
        else:
            print "Verbose mode turned off."

    def help_help(self):
        """
        Help for help command.
        """
        print "Display list of commands or description of the given command"

    #################################################################
    # RPC connection handling
    #################################################################
    def connect(self, host, port, cluster):
        """
        Actually, `connect` does not start TCP connection; just create client instance for RPC call.
        """
        self.disconnect()
        self.host = host
        self.port = port
        self.cluster = cluster
        self.client = self.get_client(host, port)
        self.update_prompt()

    def disconnect(self):
        """
        Disconnects from the server, if connected.
        """
        if self.is_connected():
            self.client.client.close()
            self.client = None

    def is_connected(self):
        """
        `is_connected` returns True, if the client can be closed.
        The TCP connection may already be closed.
        """
        return hasattr(self, 'client') and self.client is not None

    def update_prompt(self):
        """
        Call this to update the shell prompt upon reconnection etc.
        """
        if not hasattr(self, 'prompt_format'):
            self.prompt = '[Jubatus:' + self.engine_name() + '<' + self.cluster + '>@' + self.host + ':' + str(self.port) + '] # '
        else:
            pass #TODO: support custom prompt format

    #################################################################
    # Accessor to client classes
    #################################################################
    def get_client(self, host, port):
        """
        Get client instance for given host and port.
        """
        return self.get_class('.'.join(['jubatus', self.engine_name(), 'client', self.engine_name()]))(host, port)

    def get_types_class(self, name):
        """
        Get class for the data structure of given name.
        """
        return self.get_class('.'.join(['jubatus', self.engine_name(), 'types', name]))

    #################################################################
    # Utilities
    #################################################################
    @staticmethod
    def get_class(name):
        """
        Dynamically import and return a class of given name.
        """
        levels = name.split('.')
        (package, module, basename) = (levels[0], '.'.join(levels[:-1]), levels[-1])
        return getattr(__import__(module, fromlist=[package]), basename)

    @staticmethod
    def argv(param, minlen, maxlen=1):
        """
        Split arguments into array.
        Raises `ValueError` if minlen is not satisfied.
        """
        if param is not None:
            param2 = param.strip()
            if param2 != "":
                result = re.split('\s+', param2, maxlen-1)
            else:
                result = []
            if minlen <= len(result):
                return result
        raise ValueError, "Too few arguments (at least %d required)" % minlen

    @staticmethod
    def is_num(string):
        return re.match('^\d*\.?\d+$', string) is not None

    @staticmethod
    def get_engines():
        return {
            'classifier' : ClassifierShell,
            'regression' : RegressionShell,
            'recommender': RecommenderShell,
            'stat'       : StatShell,
            'graph'      : GraphShell,
            'generic'    : UnknownShell
        }

    @staticmethod
    def get(engine, host, port, cluster):
        """
        Get shell for the specified parameter.
        """
        engines = JubaShell.get_engines()
        if engine in engines:
            return engines[engine](host, port, cluster)
        return UnknownShell(host, port, cluster)

    @staticmethod
    def get_guess(host, port, cluster):
        """
        Get shell for the specified parameter.
        This method guesses what engine the server is running.
        """
        client = msgpackrpc.Client(msgpackrpc.Address(host, port))
        try:
            results = client.call('get_status', cluster)
            client.close()
        except msgpackrpc.error.RPCError as e:
            client.close()
            return

        if len(results) == 0:
            raise
        result = results.popitem()[1]
        is_standalone = True
        if 'zk' in result and result['zk'] != "":
            is_standalone = False
        if not is_standalone and cluster == "":
            raise

        prog = result['PROGNAME']
        if prog.startswith('juba'):
            prog = prog[4:]

        return JubaShell.get(prog, host, port, cluster)

class GenericShell(JubaShell):
    """
    Generic implementation of the engine-specific shell that implements
    set_config, get_config, save, load and get_status.
    This class cannot be instantiated.

    In most cases, you should inherit this class, rather than creating
    your own one from scratch for your engine.
    """

    def do_set_config(self, param):
        """Syntax: set_config algorithm [config_or_filename]
        Set algorithm and converter configuration to server.
        """
        argv = self.argv(param, 1, 2)
        algorithm = argv[0]
        if len(argv) == 1:
            config = json.dumps(self.get_generic_config(), sort_keys=True, indent=4)
        else:
            config = argv[1]
        if not config.startswith('{'):
            # TODO
            filename = argv[1]
            raise ValueError, "loading from file (%s) is not implemented yet." % filename
        clazz = self.get_types_class('config_data')
        self.client.set_config(self.cluster, clazz(algorithm, config))
        # TODO: check retval (currently returns false)

    def complete_set_config(self, text, line, begidx, endidx):
        argnum = self.computil_argnum(text, line, begidx, endidx)
        if argnum == 0:
            return self.computil_filter(text, [
                'perceptron', 'PA', 'PA1', 'PA2', 'CW', 'AROW', 'NHERD',
                'inverted_index', 'lsh', 'minhash',
                ])

    def do_get_config(self, param):
        """Syntax: get_config
        Display algorithm and converter configuration set in server.
        """
        config = self.client.get_config(self.cluster)
        self.print_config(config)

    def do_save(self, param):
        """Syntax: save model_id
        Save the model.
        """
        argv = self.argv(param, 1, 1)
        model_id = argv[0]
        if not self.client.save(self.cluster, model_id):
            print "save failed."

    def do_load(self, param):
        """Syntax: load model_id
        Load the given model.
        """
        argv = self.argv(param, 1, 1)
        model_id = argv[0]
        if not self.client.load(self.cluster, model_id):
            print "load failed."

    def do_get_status(self, param):
        """Syntax: get_status
        Displays status of servers.
        """
        status = self.client.get_status(self.cluster)
        self.print_status(status)

    def do_show_config_example(self, param):
        """Syntax: show_config_sample
        Displays example configuration.
        """
        print json.dumps(self.get_generic_config(), sort_keys=True, indent=4)

    def do_test_converter(self, param):
        pass
        # TODO: using jubaconv, test conversion for given datum

    def get_generic_config(self):
        config_template = {
            "string_filter_types": {
                "detag": { "method": "regexp", "pattern": "<[^>]*>", "replace": "" }
            },
            "string_filter_rules": [
            ],
            "num_filter_types": {
                "add_1" : { "method": "add", "value" : "1" }
            },
            "num_filter_rules": [
            ],
            "string_types": {
                "unigram" : { "method": "ngram", "char_num": "1" },
                "bigram"  : { "method": "ngram", "char_num": "2" },
                "trigram" : { "method": "ngram", "char_num": "3" }
            },
            "string_rules": [
                { "key": "*", "type": "str", "sample_weight": "bin", "global_weight": "bin" }
            ],
            "num_types": {
            },
            "num_rules": [
                { "key": "*",  "type": "num" }
            ]
        }
        return config_template

    def print_config(self, config):
        """
        Pretty-print the config structure.
        """
        config2 = config
        if hasattr(config2, 'converter'):
            print 'converter: %s' % json.dumps(json.loads(config2.__dict__.pop('converter')), sort_keys=True, indent=4)
        for key in config2.__dict__:
            print '%s: %s' % (key, getattr(config2, key))

    def print_status(self, status):
        """
        Pretty-print the status structure.
        """
        for server_port in status:
            server_stat = status[server_port]
            print "Server %s:%s" % tuple(server_port.split('_'))
            for key in server_stat:
                print "  %s: %s" % (key, server_stat[key])

    def print_datum(self, datum):
        """
        Pretty-print the datum structure.
        """
        print json.dumps({
            "string_values" : datum.string_values,
            "num_values"    : datum.num_values,
            })

class UnknownShell(GenericShell):
    """
    Shell for unknown server engines.
    """
    def engine_name(self):
        return 'unknown'

    def get_client(self, host, port):
        return UnknownShell.UnknownClient(host, port)

    def get_types_class(self, name):
        if name == "config_data":
            return UnknownShell.UnknownTypes.config_data
        raise "Unsupported type"

    class UnknownClient():
        def __init__(self, host, port):
            address = msgpackrpc.Address(host, port)
            self.client = msgpackrpc.Client(address)

        def set_config(self, name, c):
            return self.client.call('set_config', name, c)

        def get_config(self, name):
            return self.client.call('get_config', name)

        def save(self, name, model_id):
            return self.client.call('save', model_id)

        def load(self, name, model_id):
            return self.client.call('load', model_id)

        def get_status(self, name):
            return self.client.call('get_status', name)

    class UnknownTypes():
        class config_data():
            def __init__(self, method, config):
                self.method = method
                self.config = config

            def to_msgpack(self):
                return (self.method, self.config)

            @staticmethod
            def from_msgpack(arg):
                return config_data(arg[0], arg[1])

class ClassifierShell(GenericShell):
    def engine_name(self):
        return 'classifier'

    def do_train(self, param):
        """Syntax: train label datum_key datum_value [datum_key datum_value ...]
        Trains the model with given label and datum.
        Bulk training is not supported on the command line.
        """
        argv = self.argv(param, 3)
        label = argv[0]
        d = self.argv2datum(argv[1:])
        self.verbose("train: label = %s" % label)
        self.verbose("  datum = %s" % d.__dict__)
        self.client.train(self.cluster, [(label, d)])

    def do_classify(self, param):
        """Syntax: classify datum_key datum_value [datum_key datum_value ...]
        Classify the given datum.
        Bulk classification is not supported on the command line.
        """
        argv = self.argv(param, 2)
        d = self.argv2datum(argv)
        self.verbose("classify:")
        self.verbose("  datum = %s" % d.__dict__)
        results = self.client.classify(self.cluster, [d])[0]
        for result in results:
            print "%s: %s" % (result.label, str(result.prob))

class RegressionShell(GenericShell):
    def engine_name(self):
        return 'regression'

    def do_train(self, param):
        """Syntax: train label datum_key datum_value [datum_key datum_value ...]
        Trains the model with given label and datum.
        Bulk training is not supported on the command line.
        """
        argv = self.argv(param, 3)
        label = float(argv[0])
        d = self.argv2datum(argv[1:])
        self.verbose("train: label = %s" % label)
        self.verbose("  datum = %s" % d.__dict__)
        self.client.train(self.cluster, [(label, d)])

    def do_estimate(self, param):
        """Syntax: estimate datum_key datum_value [datum_key datum_value ...]
        Estimate the value for the given datum.
        Bulk estimation is not supported on the command line.
        """
        argv = self.argv(param, 2)
        d = self.argv2datum(argv)
        self.verbose("estimate:")
        self.verbose("  datum = %s" % d.__dict__)
        result = self.client.estimate(self.cluster, [d])[0]
        print "%s" % str(result)

class RecommenderShell(GenericShell):
    def engine_name(self):
        return 'recommender'

    def do_clear_row(self, param):
        """Syntax: clear_row row_id
        Clear the specified row.
        """
        argv = self.argv(param, 1)
        row_id = argv[0]
        self.client.clear(self.cluster, row_id)
        # TODO: check retval

    def do_update_row(self, param):
        """Syntax: update_row row_id datum_key datum_value [datum_key datum_value ...]
        Update or insert a new row.
        """
        argv = self.argv(param, 3)
        row_id = argv[0]
        d = self.argv2datum(argv[1:])
        self.verbose("update_row ID: %s" % row_id)
        self.verbose("  datum = %s" % d.__dict__)
        self.client.update_row(self.cluster, row_id, d)

    def do_clear(self, param):
        """Syntax: clear
        Clear the model.
        """
        self.client.clear(self.cluster)
        # TODO: check retval

    def do_complete_row_from_id(self, param):
        """Syntax: complete_row_from_id id
        Complete row from the given ID.
        """
        argv = self.argv(param, 1, 1)
        row_id = argv[0]
        d = self.client.complete_row_from_id(self.cluster, row_id)
        self.print_datum(d)

    def do_complete_row_from_data(self, param):
        """syntax: complete_row_from_data datum_key datum_value [datum_key datum_value ...]
        Complete row from the given datum.
        """
        argv = self.argv(param, 2)
        d = self.argv2datum(argv)
        d = self.client.complete_row_from_data(self.cluster, d)
        self.print_datum(d)

    def do_similar_row_from_id(self, param):
        """Syntax: similar_row_from_id id
        Similar row from the given ID.
        """
        argv = self.argv(param, 1, 1)
        row_id = argv[0]
        d = self.client.similar_row_from_id(self.cluster, row_id)
        self.print_datum(d)

    def do_similar_row_from_data(self, param):
        """syntax: similar_row_from_data datum_key datum_value [datum_key datum_value ...]
        Similar row from the given datum.
        """
        argv = self.argv(param, 2)
        d = self.argv2datum(argv)
        d = self.client.similar_row_from_data(self.cluster, d)
        self.print_datum(d)

    def do_decode_row(self, param):
        """Syntax: decode_row id
        Decode the row of given ID.
        """
        argv = self.argv(param, 1, 1)
        row_id = argv[0]
        d = self.client.decode_row(self.cluster, row_id)
        self.print_datum(d)

    def do_get_all_rows(self, param):
        """Syntax: get_all_rows
        Returns all rows. Note that converted rows will not be displayed."""
        rows = self.client.get_all_rows(self.cluster)
        for row in rows:
            print row

    def do_similarity(self, param):
        print "not implemented yet."

    def do_l2norm(self, param):
        print "not implemented yet."

class StatShell(GenericShell):
    def engine_name(self):
        return 'stat'

    def do_set_config(self, param):
        """Syntax: set_config window_size
        Set window size.
        """
        argv = self.argv(param, 1, 1)
        window_size = int(argv[0])
        clazz = self.get_types_class('config_data')
        self.client.set_config(self.cluster, clazz(window_size))

    def do_push(self, param):
        """Syntax: push key value
        Add value for the specified key.
        """
        argv = self.argv(param, 2, 2)
        key = str(argv[0])
        value = float(argv[1])
        self.client.push(self.cluster, key, value)

    def do_sum(self, param):
        """Syntax: sum key
        Get sum for the specified key.
        """
        argv = self.argv(param, 1, 1)
        key = str(argv[0])
        print self.client.sum(self.cluster, key)

    def do_stddev(self, param):
        """Syntax: stddev key
        Get stddev for the specified key.
        """
        argv = self.argv(param, 1, 1)
        key = str(argv[0])
        print self.client.stddev(self.cluster, key)

    def do_max(self, param):
        """Syntax: max key
        Get max for the specified key.
        """
        argv = self.argv(param, 1, 1)
        key = str(argv[0])
        print self.client.max(self.cluster, key)

    def do_min(self, param):
        """Syntax: min key
        Get min for the specified key.
        """
        argv = self.argv(param, 1, 1)
        key = str(argv[0])
        print self.client.min(self.cluster, key)

    def do_entropy(self, param):
        """Syntax: entropy key
        Get entropy for the specified key.
        """
        argv = self.argv(param, 1, 1)
        key = str(argv[0])
        print self.client.entropy(self.cluster, key)

    def do_moment(self, param):
        """Syntax: moment key n c
        Get moment for the specified key.
        """
        argv = self.argv(param, 3, 3)
        key = str(argv[0])
        n = int(argv[1])
        c = float(argv[2])
        print self.client.moment(self.cluster, key, n, c)

class GraphShell(GenericShell):
    def engine_name(self):
        return 'graph'

    def do_set_config(self, param):
        print "Graph does not support set_config"

    def do_get_config(self, param):
        print "Graph does not support get_config"

    def do_create_node(self, param):
        """Syntax: create_node
        Create node.
        """
        node_id = self.client.create_node(self.cluster)
        print "%s" % node_id

    def do_remove_node(self, param):
        """Syntax: remove_node node_id
        Remove the specified node.
        """
        argv = self.argv(param, 1, 1)
        node_id = str(argv[0])
        self.client.remove_node(self.cluster, node_id)

    def do_update_node(self, param):
        """Syntax: update_node node_id [property_key property_value ...]
        Update node.
        """
        argv = self.argv(param, 1)
        node_id = argv[0]
        prop = self.argv2property(argv[1:])
        self.client.update_node(self.cluster, node_id, prop)

    def do_create_edge(self, param):
        """Syntax: create_edge from_node to_node [property_key property_value ...]
        Create edge.
        """
        argv = self.argv(param, 2)
        from_node_id = str(argv[0])
        to_node_id = str(argv[1])
        prop = self.argv2property(argv[2:])
        info = self.get_types_class('edge_info')(prop, from_node_id, to_node_id)
        self.client.create_edge(self.cluster, from_node_id, info)

    def do_update_edge(self, param):
        """Syntax: update_edge edge_id from_node to_node [property_key property_value ...]
        Update edge.
        """
        argv = self.argv(param, 3)
        edge_id = long(argv[0])
        from_node_id = str(argv[1])
        to_node_id = str(argv[2])
        prop = self.argv2property(argv[3:])
        info = self.get_types_class('edge_info')(prop, from_node_id, to_node_id)
        self.client.update_edge(self.cluster, from_node_id, edge_id, info)

    def do_remove_edge(self, param):
        """Syntax: remove_edge edge_id from_node
        Remove the specified edge.
        """
        argv = self.argv(param, 2)
        edge_id = long(argv[0])
        from_node_id = str(argv[1])
        self.client.remove_edge(self.cluster, from_node_id, edge_id)

    def do_centrality(self, param):
        """Syntax: do_centrality node_id [type]
        Calculate centrality for the node.
        "type" is 0 (PageRank) by default.
        Queries are not supported (empty query is used).
        """
        argv = self.argv(param, 1, 2)
        node_id = str(argv[0])
        c_type = 0
        query = self.get_types_class('preset_query')([], [])
        if len(argv) == 2:
            c_type = int(argv[1])
        self.client.centrality(self.cluster, node_id, c_type, query)

    def do_add_centrality_query(self, param):
        """Syntax: add_centrality_query
        Preset empty query.
        """
        query = self.get_types_class('preset_query')([], [])
        self.client.add_centrality_query(self.cluster, query)

    def do_add_shortest_path_query(self, param):
        print "not implemented yet."

    def do_remove_centrality_query(self, param):
        print "not implemented yet."

    def do_remove_shortest_path_query(self, param):
        print "not implemented yet."

    def do_shortest_path(self, param):
        print "not implemented yet."

    def do_update_index(self, param):
        print "not implemented yet."

    def do_clear(self, param):
        """Syntax: clear
        Clear the model.
        """
        self.client.clear(self.cluster)

    def do_get_node(self, param):
        """Syntax: get_node node_id
        Get node information.
        """
        argv = self.argv(param, 1)
        node_id = str(argv[0])
        info = self.client.get_node(self.cluster, node_id)
        print "Properties:"
        for key in info.p:
            print "  %s: %s" % (key, info.p[key])
        print "In-Edges:"
        print "  %s" % str(info.in_edges)
        print "Out-Edges:"
        print "  %s" % str(info.out_edges)

    def do_get_edge(self, param):
        """Syntax: get_edge edge_id from_node_id
        Get edge information.
        """
        argv = self.argv(param, 2)
        edge_id = long(argv[0])
        from_node_id = long(argv[1])
        info = self.client.get_node(self.cluster, node_id)
        print "Properties:"
        for key in info.p:
            print "  %s: %s" % (key, info.p[key])
        print "In-Edges:"
        print "  %s" % str(info.in_edges)
        print "Out-Edges:"
        print "  %s" % str(info.out_edges)

    def argv2property(self, argv):
        if len(argv) % 2 != 0:
            raise ValueError, "value for the last property is missing"

        prop_values = {}
        for i in range(len(argv) / 2):
            prop_values[str(argv[i*2])] = str(argv[i*2+1])
        return prop_values

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Jubatus Interactive Shell Environment')
    parser.add_argument('--host',    '-H', type=str, default="127.0.0.1")
    parser.add_argument('--port',    '-P', type=int, default=9199)
    parser.add_argument('--cluster', '-C', type=str, default="")
    parser.add_argument('--engine',  '-e', type=str, default=None, choices=JubaShell.get_engines().keys())
    parser.add_argument('--command', '-c', type=str, default=None)
    parser.add_argument('--script',  '-f', type=str, default=None)
    args = parser.parse_args()

    if args.engine is None:
        shell = JubaShell.get_guess(args.host, args.port, args.cluster)
        if shell is None:
            print "Failed to connect"
            sys.exit(1)
    else:
        shell = JubaShell.get(args.engine, args.host, args.port, args.cluster)

    if args.script is not None:
        print "Scripting is not implemented yet."
        sys.exit(1)

    shell.start(args.command)
