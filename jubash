#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
  _________         ___
  \____   _|       | /             ___I_I___
      |  |         | |             \__^ ^__/        ____
      |  |         | | ___    ___  __ | |          / __/
      |  | |-|  |-|| |/   \  /   \| | | | |^|  |^|| (__
      |  | | |  | ||    ^  ||  ^    | | | | |  | | \__ \
      |  | | \_/  ||    O   || O    | | |_| \_/  | ___) |
      |  |  \__/|_||_|\___/  \___/|_| |__/ \__/|_| \___/
      | /
     / /
    |/

Jubash - Jubatus Interactive Shell Environment
Copyright Â© 2012-2013 Kenichi Maehashi. All rights reserved.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License version 2.1 as published by the Free Software Foundation.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
'''

import sys
import cmd
import shlex
import argparse
import re
import json
import msgpackrpc
import subprocess

class ExtendedCmd(cmd.Cmd, object):
    def parseline(self, line):
        line = line.strip()
        if not line:
            return None, None, line
        elif line[0] == '?':
            line = 'help ' + line[1:]
        elif line[0] == '!':
            if hasattr(self, 'do_shell'):
                line = 'shell ' + line[1:]
            else:
                return None, None, line
        i, n = 0, len(line)
        while i < n and line[i] in self.identchars: i = i+1
        cmd, arg = line[:i], line[i:].strip()
        return cmd, arg, line

    def complete(self, text, state):
        result = super(ExtendedCmd, self).complete(text, state)
        if len(self.completion_matches) == 1:
            return self.completion_matches[state] + ' ' if state == 0 else None
        return result

class JubaShell(ExtendedCmd):
    """
    Base class of Jubatus shell
    """
    def __init__(self, host, port, cluster, verbose_mode, keepalive, prompt_format):
        super(JubaShell, self).__init__()

        # Server configuration
        self.client = None
        self.host = host
        self.port = port
        self.cluster = cluster
        self.keepalive = keepalive
        self.timeout = 10

        # Shell configuration
        self.verbose_mode = verbose_mode
        if not prompt_format:
            prompt_format = '[Jubatus:%(engine)s<%(cluster)s>@%(host)s:%(port)s] # '
        self.prompt_format = prompt_format

        # Help configuration
        self.doc_header = "Commands:"
        self.undoc_header = "Commands (no help available):"
        self.misc_header = "Documents:"
        self.nohelp = "No help available for %s."

        # Register aliases
        self.register_alias('EOF', 'do_exit')
        self.register_alias('ls', 'do_help')
        self.register_alias('shell', 'shell_command')

    @staticmethod
    def engine_name():
        """
        Return the name of the engine (e.g., `classifier`).
        You must override this in subclasses.
        """
        raise NotImplementedError

    def start(self):
        """
        Start the interactive shell.
        """
        self.update_prompt()
        while True:
            try:
                self.connect()
                self.cmdloop()
                return
            except ValueError as e:
                print "Invalid argument: %s; use `help` command for details" % str(e.message)
            except msgpackrpc.error.RPCError as e:
                print "RPC Error: " + str(e.message)
            except KeyboardInterrupt: # trap Ctrl-C
                print
            except JubaShellFatalError as e:
                print "Fatal Error: " + str(e.message)
                break
            finally:
                self.disconnect()

    def run(self, command):
        """
        Run the given single command.
        """
        try:
            self.connect()
            print ">> %s" % command
            stop = self.onecmd(command)
            return True
        except ValueError as e:
            print "Invalid argument: %s" % str(e.message)
            return False
        except msgpackrpc.error.RPCError as e:
            print "RPC Error: " + str(e.message)
            return False
        except KeyboardInterrupt: # trap Ctrl-C
            print "Interrupted."
            return False
        except BaseException as e:
            print "Fatal Error: " + str(e.message)
            return False
        finally:
            self.disconnect()

    def postcmd(self, stop, line):
        if not self.keepalive:
            self.disconnect()
            self.connect()
        return stop

    def emptyline(self):
        """
        By default, empty line causes the previous command to run again.
        This overrides the default handler for emptyline so it behaves like the usual shell.
        """
        pass

    def default(self, line):
        print "Unknown command: %s" % line
        print "Type `help` for commands available."

    def shell_command(self, param):
        subprocess.call(param, shell=True)

    def verbose(self, msg):
        if self.verbose_mode:
            print msg

    def register_alias(self, alias, name):
        """
        Register alias function to the method.
        Aliases are not listed by `help` command.
        """
        self.__dict__['do_' + alias] = getattr(self, name)

    def update_prompt(self):
        """
        Call this to update the shell prompt upon reconnection etc.
        """
        self.prompt = self.prompt_format % {'engine': self.engine_name(), 'cluster': self.cluster, 'host': self.host, 'port': str(self.port)}

    #################################################################
    # Built-in commands
    #################################################################
    def do_exit(self, param):
        """Syntax: exit
        Exit the shell. You can also use EOF (Ctrl-D).
        """
        print
        return True

    def do_connect(self, param):
        """Syntax: connect host port [cluster]
        Connect to the specified host, port and cluster (optional).
        """
        argv = self.argv(param, 2, 3)
        host = argv[0]
        port = int(argv[1])
        cluster = self.cluster
        if len(argv) == 3:
            cluster = argv[2]
        self.disconnect()

        print "Connecting to <%s>@%s:%d..." % (cluster, host, port)
        self.host = host
        self.port = port
        self.cluster = cluster
        self.connect()
        self.update_prompt()

    def do_reconnect(self, param):
        """Syntax: reconnect
        Reconnects to the current server.
        """
        argv = self.argv(param, 0, 0)
        self.connect()

    def do_verbose(self, param):
        """Syntax: verbose
        Toggles the verbose mode.
        """
        argv = self.argv(param, 0, 0)
        self.verbose_mode = not self.verbose_mode
        if self.verbose_mode:
            print "Verbose mode turned on."
        else:
            print "Verbose mode turned off."

    def do_keepalive(self, param):
        """Syntax: keepalive
        Toggle the keepalive mode.
        """
        argv = self.argv(param, 0, 0)
        self.keepalive = not self.keepalive
        if self.keepalive:
            print "Keepalive is enabled"
        else:
            print "Keepalive is disabled"

    def do_get_timeout(self, param):
        """Syntax: get_timeout
        Display the client-side timeout.
        """
        argv = self.argv(param, 0, 0)
        print("Timeout: %d seconds" % self.client.client._timeout)

    def do_set_timeout(self, param):
        """Syntax: set_timeout seconds
        Set the client-side timeout in seconds.
        """
        argv = self.argv(param, 1, 1)
        self.timeout = int(argv[0])
        self.client.client._timeout = self.timeout

    def help_help(self):
        """
        Help for help command.
        """
        print "Display list of commands or description of the given command"

    #################################################################
    # RPC connection handling
    #################################################################
    def connect(self):
        """
        Discard the current connection (if connected) and create new client instance.
        Note that TCP connection will not be established until RPC method is called.
        """
        if self.is_connected():
            self.disconnect()
        self.client = self.get_client(self.host, self.port)
        self.client.client._timeout = self.timeout

    def disconnect(self):
        """
        Disconnects from the server (if connected).
        """
        if self.is_connected():
            self.client.client.close()
            self.client = None

    def is_connected(self):
        """
        `is_connected` returns True, if the client can be closed.
        The TCP connection may already be closed.
        """
        return self.client is not None

    #################################################################
    # Accessor to client classes
    #################################################################
    def get_client(self, host, port):
        """
        Get client instance for given host and port.
        """
        try:
            return self.get_class('.'.join(['jubatus', self.engine_name(), 'client', self.engine_name()]))(host, port)
        except AttributeError:
            raise JubaShellFatalError(\
                'Failed to create the client instance.\n' + \
                'Maybe you have not installed Jubatus Python client library or the installed one is incompatible with this version of Jubash.')

    def get_types_class(self, name):
        """
        Get class for the data structure of given name.
        """
        try:
            return self.get_class('.'.join(['jubatus', self.engine_name(), 'types', name]))
        except AttributeError:
            raise JubaShellFatalError(\
                'Failed to create the data structure instance.\n' + \
                'Maybe you have not installed Jubatus Python client library or the installed one is incompatible with this version of Jubash.')

    #################################################################
    # Utilities
    #################################################################
    @staticmethod
    def get_class(name):
        """
        Dynamically import and return a class of given name.
        """
        levels = name.split('.')
        (package, module, basename) = (levels[0], '.'.join(levels[:-1]), levels[-1])
        return getattr(__import__(module, fromlist=[package]), basename)

    @staticmethod
    def get_shells():
        shells = {}
        work = [JubaShell]
        while work:
            parent = work.pop()
            for child in parent.__subclasses__():
                if child not in shells.values():
                    work.append(child)
                    try:
                        name = child.engine_name()
                    except NotImplementedError: # child is an abstract class
                        continue
                    shells[name] = child
        return shells

    @staticmethod
    def argv(param, minlen, maxlen=-1):
        """
        Split arguments into array.
        Raises `ValueError` if the length condition is not satisfied.
        """
        if param is not None and param != "":
            result = shlex.split(param)
        else:
            result = []
        if len(result) < minlen:
            raise ValueError, "Too few arguments (%d requred at least)" % minlen
        if 0 <= maxlen and maxlen < len(result):
            if maxlen == 0:
                raise ValueError, "Too much arguments (no arguments allowed)"
            else:
                raise ValueError, "Too much arguments (%d required at most)" % maxlen
        return result

    @staticmethod
    def get(host, port, cluster, engine, verbose_mode, keepalive, prompt_format):
        """
        Get shell for the specified parameter.
        """
        if not engine:
            # guess the engine from get_status
            client = msgpackrpc.Client(msgpackrpc.Address(host, port))
            try:
                results = client.call('get_status', cluster)
                if len(results) == 0:
                    raise JubaShellDetectionFailedError('Got empty reply from server', host, port)
            except msgpackrpc.error.RPCError as e:
                raise JubaShellDetectionFailedError('RPC error when requesting get_status to server', host, port)
            finally:
                client.close()
            result1 = results.popitem()[1]
            if not 'PROGNAME' in result1:
                raise JubaShellDetectionFailedError('No program name returned from server', host, port)
            engine = result1['PROGNAME']
            if engine.startswith('juba'):
                engine = engine[4:]
        shells = JubaShell.get_shells()
        if engine in shells.keys():
            return shells[engine](host, port, cluster, verbose_mode, keepalive, prompt_format)
        return GenericShell(host, port, cluster, verbose_mode, keepalive, prompt_format)

    @staticmethod
    def computil_argnum(text, line, begidx, endidx):
        return len(JubaShell.argv(line[0:begidx],0)) - 1

    @staticmethod
    def computil_filter(text, candidates):
        return [x for x in candidates if x.startswith(text)]

class JubaShellDetectionFailedError(Exception):
    def __init__(self, msg, host, port):
        super(JubaShellDetectionFailedError, self).__init__(msg + ' (%s:%d)' % (host, port))

class JubaShellFatalError(Exception):
    def __init__(self, *args, **kwargs):
        super(JubaShellFatalError, self).__init__(*args, **kwargs)

class AbstractGenericShell(JubaShell):
    """
    Generic implementation of the engine-specific shell that implements
    get_config, save, load, clear and get_status.
    This class cannot be instantiated.

    In most cases, you should inherit this class, rather than creating
    your own one from scratch for your engine.
    """

    def do_get_config(self, param):
        """Syntax: get_config
        Display algorithm and converter configuration set in server.
        """
        argv = self.argv(param, 0, 0)
        config = self.client.get_config(self.cluster)
        print json.dumps(json.loads(config), sort_keys=True, indent=4)

    def do_save(self, param):
        """Syntax: save model_id
        Save the model.
        """
        argv = self.argv(param, 1, 1)
        model_id = argv[0]
        result = self.client.save(self.cluster, model_id)
        if not result:
            print "Failed"

    def do_clear(self, param):
        """Syntax: clear
        Clear the model.
        """
        argv = self.argv(param, 0, 0)
        result = self.client.clear(self.cluster)
        if not result:
            print "Failed"

    def do_load(self, param):
        """Syntax: load model_id
        Load the given model.
        """
        argv = self.argv(param, 1, 1)
        model_id = argv[0]
        result = self.client.load(self.cluster, model_id)
        if not result:
            print "Failed"

    def do_get_status(self, param):
        """Syntax: get_status
        Displays status of servers.
        """
        argv = self.argv(param, 0, 0)
        status = self.client.get_status(self.cluster)
        self.print_status(status)

    def argv2datum(self, argv):
        if len(argv) % 2 != 0:
            raise ValueError, "value for the last datum is missing"

        string_values = []
        num_values = []
        for i in range(len(argv) / 2):
            feat_key = argv[i*2]
            feat_val = argv[i*2+1]
            try:
                num_values.append((feat_key, float(feat_val)))
            except ValueError:
                string_values.append((feat_key, feat_val))
        return self.get_types_class('datum')(string_values, num_values)

    def print_status(self, status):
        """
        Pretty-print the status structure.
        """
        for server_port in status:
            server_stat = status[server_port]
            print "Server %s:%s" % tuple(server_port.split('_'))
            for key in sorted(server_stat.keys()):
                print "  %s: %s" % (key, server_stat[key])

    def print_datum(self, datum):
        """
        Pretty-print the datum structure.
        """
        print json.dumps({
            "string_values" : datum.string_values,
            "num_values"    : datum.num_values,
            })

class GenericShell(AbstractGenericShell):
    """
    Shell for unknown server engines.
    """
    @staticmethod
    def engine_name():
        return 'generic'

    def get_client(self, host, port):
        return GenericShell.GenericClient(host, port)

    class GenericClient():
        def __init__(self, host, port):
            address = msgpackrpc.Address(host, port)
            self.client = msgpackrpc.Client(address)

        def get_config(self, name):
            return self.client.call('get_config', name)

        def save(self, name, model_id):
            return self.client.call('save', name, model_id)

        def load(self, name, model_id):
            return self.client.call('load', name, model_id)

        def clear(self, name):
            return self.client.call('clear', name)

        def get_status(self, name):
            return self.client.call('get_status', name)

class ClassifierShell(AbstractGenericShell):
    cached_labels = set()

    @staticmethod
    def engine_name():
        return 'classifier'

    def do_train(self, param):
        """Syntax: train label datum_key datum_value [datum_key datum_value ...]
        Trains the model with given label and datum.
        Bulk training is not supported on the command line.
        """
        argv = self.argv(param, 3)
        label = argv[0]
        d = self.argv2datum(argv[1:])
        self.verbose("train: label = %s" % label)
        self.verbose("  datum = %s" % d.__dict__)
        result = self.client.train(self.cluster, [(label, d)])
        if result != 1:
            print "Failed"
        self.cached_labels.add(label)

    def complete_train(self, text, line, begidx, endidx):
        argnum = self.computil_argnum(text, line, begidx, endidx)
        if argnum == 0:
            return self.computil_filter(text, self.cached_labels)

    def do_classify(self, param):
        """Syntax: classify datum_key datum_value [datum_key datum_value ...]
        Classify the given datum.
        Bulk classification is not supported on the command line.
        """
        argv = self.argv(param, 2)
        d = self.argv2datum(argv)
        self.verbose("classify:")
        self.verbose("  datum = %s" % d.__dict__)
        results = self.client.classify(self.cluster, [d])[0]
        results.sort(key=lambda e: e.score, reverse=True)
        for result in results:
            print "%s: %s" % (result.label, str(result.score))
            self.cached_labels.add(result.label)

class RegressionShell(AbstractGenericShell):
    @staticmethod
    def engine_name():
        return 'regression'

    def do_train(self, param):
        """Syntax: train label datum_key datum_value [datum_key datum_value ...]
        Trains the model with given label and datum.
        Bulk training is not supported on the command line.
        """
        argv = self.argv(param, 3)
        label = float(argv[0])
        d = self.argv2datum(argv[1:])
        self.verbose("train: label = %s" % label)
        self.verbose("  datum = %s" % d.__dict__)
        result = self.client.train(self.cluster, [(label, d)])
        if result != 1:
            print "Failed"

    def do_estimate(self, param):
        """Syntax: estimate datum_key datum_value [datum_key datum_value ...]
        Estimate the value for the given datum.
        Bulk estimation is not supported on the command line.
        """
        argv = self.argv(param, 2)
        d = self.argv2datum(argv)
        self.verbose("estimate:")
        self.verbose("  datum = %s" % d.__dict__)
        result = self.client.estimate(self.cluster, [d])[0]
        print "%s" % str(result)

class RecommenderShell(AbstractGenericShell):
    max_results = 100

    @staticmethod
    def engine_name():
        return 'recommender'

    def do_clear_row(self, param):
        """Syntax: clear_row row_id
        Clear the specified row.
        """
        argv = self.argv(param, 1, 1)
        row_id = argv[0]
        result = self.client.clear_row(self.cluster, row_id)
        if not result:
            print "Failed"

    def do_update_row(self, param):
        """Syntax: update_row row_id datum_key datum_value [datum_key datum_value ...]
        Update or insert a new row.
        """
        argv = self.argv(param, 3)
        row_id = argv[0]
        d = self.argv2datum(argv[1:])
        self.verbose("update_row ID: %s" % row_id)
        self.verbose("  datum = %s" % d.__dict__)
        result = self.client.update_row(self.cluster, row_id, d)
        if not result:
            print "Failed"

    def do_complete_row_from_id(self, param):
        """Syntax: complete_row_from_id id
        Complete row from the given ID.
        """
        argv = self.argv(param, 1, 1)
        row_id = argv[0]
        d = self.client.complete_row_from_id(self.cluster, row_id)
        self.print_datum(d)

    def do_complete_row_from_datum(self, param):
        """syntax: complete_row_from_datum datum_key datum_value [datum_key datum_value ...]
        Complete row from the given datum.
        """
        argv = self.argv(param, 2)
        d = self.argv2datum(argv)
        d = self.client.complete_row_from_datum(self.cluster, d)
        self.print_datum(d)

    def do_similar_row_from_id(self, param):
        """Syntax: similar_row_from_id id
        Similar row from the given ID.
        """
        argv = self.argv(param, 1, 1)
        row_id = argv[0]
        results = self.client.similar_row_from_id(self.cluster, row_id, self.max_results)
        self.print_similar_result(results)

    def do_similar_row_from_datum(self, param):
        """syntax: similar_row_from_datum datum_key datum_value [datum_key datum_value ...]
        Similar row from the given datum.
        """
        argv = self.argv(param, 2)
        d = self.argv2datum(argv)
        results = self.client.similar_row_from_datum(self.cluster, d, self.max_results)
        self.print_similar_result(results)

    def do_decode_row(self, param):
        """Syntax: decode_row id
        Decode the row of given ID.
        """
        argv = self.argv(param, 1, 1)
        row_id = argv[0]
        d = self.client.decode_row(self.cluster, row_id)
        self.print_datum(d)

    def do_get_all_rows(self, param):
        """Syntax: get_all_rows
        Returns all rows. Note that converted rows will not be displayed.
        """
        argv = self.argv(param, 0, 0)
        rows = self.client.get_all_rows(self.cluster)
        for row in rows:
            print row

    def do_calc_similarity(self, param):
        """Syntax: calc_similarity datum1_key datum1_value ... | datum2_key datum2_value ...
        Calculates similarity between two datum.
        Separate two datum records with a bar ('|').
        """
        argv = self.argv(param, 4)
        rhs_offset = argv.index('|')
        lhs = self.argv2datum(argv[:rhs_offset])
        rhs = self.argv2datum(argv[rhs_offset+1:])
        similarity = self.client.calc_similarity(self.cluster, lhs, rhs)
        print similarity

    def do_calc_l2norm(self, param):
        """Syntax: calc_l2norm datum_key datum_value ...
        Calculates L2 norm for the given datum.
        """
        argv = self.argv(param, 2)
        d = self.argv2datum(argv)
        self.print_datum(d)
        l2norm = self.client.calc_l2norm(self.cluster, d)
        print l2norm

    def do_max_results(self, param):
        """Syntax: max_results [new_value]
        Displays or changes the maximum number of results for similar_row_from_{id,datum}.
        """
        argv = self.argv(param, 0, 1)
        if len(argv) == 0:
            print self.max_results
        else:
            self.max_results = int(argv[0])

    def print_similar_result(self, results):
        results.sort(key=lambda e: e[1], reverse=True)
        for result in results:
            print "%s: %g" % (result[0], result[1])

class StatShell(AbstractGenericShell):
    @staticmethod
    def engine_name():
        return 'stat'

    def do_push(self, param):
        """Syntax: push key value
        Add value for the specified key.
        """
        argv = self.argv(param, 2, 2)
        key = str(argv[0])
        value = float(argv[1])
        result = self.client.push(self.cluster, key, value)
        if not result:
            print "Failed"

    def do_sum(self, param):
        """Syntax: sum key
        Get sum for the specified key.
        """
        argv = self.argv(param, 1, 1)
        key = str(argv[0])
        print self.client.sum(self.cluster, key)

    def do_stddev(self, param):
        """Syntax: stddev key
        Get stddev for the specified key.
        """
        argv = self.argv(param, 1, 1)
        key = str(argv[0])
        print self.client.stddev(self.cluster, key)

    def do_max(self, param):
        """Syntax: max key
        Get max for the specified key.
        """
        argv = self.argv(param, 1, 1)
        key = str(argv[0])
        print self.client.max(self.cluster, key)

    def do_min(self, param):
        """Syntax: min key
        Get min for the specified key.
        """
        argv = self.argv(param, 1, 1)
        key = str(argv[0])
        print self.client.min(self.cluster, key)

    def do_entropy(self, param):
        """Syntax: entropy key
        Get entropy for the specified key.
        """
        argv = self.argv(param, 1, 1)
        key = str(argv[0])
        print self.client.entropy(self.cluster, key)

    def do_moment(self, param):
        """Syntax: moment key n c
        Get n-th moment about c of values in the specified key.
        """
        argv = self.argv(param, 3, 3)
        key = str(argv[0])
        n = int(argv[1])
        c = float(argv[2])
        print self.client.moment(self.cluster, key, n, c)

class GraphShell(AbstractGenericShell):
    @staticmethod
    def engine_name():
        return 'graph'

    def do_create_node(self, param):
        """Syntax: create_node
        Create node.
        """
        argv = self.argv(param, 0, 0)
        node_id = self.client.create_node(self.cluster)
        print "%s" % node_id

    def do_remove_node(self, param):
        """Syntax: remove_node node_id
        Remove the specified node.
        """
        argv = self.argv(param, 1, 1)
        node_id = str(argv[0])
        result = self.client.remove_node(self.cluster, node_id)
        if not result:
            print "Failed"

    def do_update_node(self, param):
        """Syntax: update_node node_id [property_key property_value ...]
        Update node.
        """
        argv = self.argv(param, 1)
        node_id = argv[0]
        prop = self.argv2property(argv[1:])
        result = self.client.update_node(self.cluster, node_id, prop)
        if not result:
            print "Failed"

    def do_create_edge(self, param):
        """Syntax: create_edge from_node to_node [property_key property_value ...]
        Create edge.
        """
        argv = self.argv(param, 2)
        from_node_id = str(argv[0])
        to_node_id = str(argv[1])
        prop = self.argv2property(argv[2:])
        info = self.get_types_class('edge')(prop, from_node_id, to_node_id)
        result = self.client.create_edge(self.cluster, from_node_id, info)
        print "Edge ID: %s" % str(result)

    def do_update_edge(self, param):
        """Syntax: update_edge edge_id from_node to_node [property_key property_value ...]
        Update edge.
        """
        argv = self.argv(param, 3)
        edge_id = long(argv[0])
        from_node_id = str(argv[1])
        to_node_id = str(argv[2])
        prop = self.argv2property(argv[3:])
        info = self.get_types_class('edge')(prop, from_node_id, to_node_id)
        result = self.client.update_edge(self.cluster, from_node_id, edge_id, info)
        if not result:
            print "Failed"

    def do_remove_edge(self, param):
        """Syntax: remove_edge edge_id [from_node]
        Remove the specified edge.
        from_node is mandatory when in distributed mode.
        """
        argv = self.argv(param, 1, 2)
        edge_id = long(argv[0])
        from_node_id = ""
        if len(argv) == 2:
            from_node_id = str(argv[1])
        result = self.client.remove_edge(self.cluster, from_node_id, edge_id)
        if not result:
            print "Failed"

    def do_get_centrality(self, param):
        """Syntax: get_centrality node_id [type]
        Calculate centrality for the node.
        "type" is 0 (PageRank) by default.
        Currenetly, only empty query is supported.
        """
        argv = self.argv(param, 1, 2)
        node_id = str(argv[0])
        c_type = 0
        query = self.get_types_class('preset_query')([], [])
        if len(argv) == 2:
            c_type = int(argv[1])
        centrality = self.client.get_centrality(self.cluster, node_id, c_type, query)
        print "%s" % str(centrality)

    def do_add_centrality_query(self, param):
        """Syntax: add_centrality_query
        Preset centrality query.
        Currenetly, only empty query is supported.
        """
        argv = self.argv(param, 0, 0)
        query = self.get_types_class('preset_query')([], [])
        result = self.client.add_centrality_query(self.cluster, query)
        if not result:
            print "Failed"

    def do_add_shortest_path_query(self, param):
        """Syntax: add_shortest_path_query
        Preset shortest_path query.
        Currenetly, only empty query is supported.
        """
        argv = self.argv(param, 0, 0)
        query = self.get_types_class('preset_query')([], [])
        result = self.client.add_shortest_path_query(self.cluster, query)
        if not result:
            print "Failed"

    def do_remove_centrality_query(self, param):
        """Syntax: remove_centrality_query
        Remove preset centrality query.
        Currenetly, only empty query is supported.
        """
        argv = self.argv(param, 0, 0)
        query = self.get_types_class('preset_query')([], [])
        result = self.client.remove_centrality_query(self.cluster, query)
        if not result:
            print "Failed"

    def do_remove_shortest_path_query(self, param):
        """Syntax: remove_shortest_path_query
        Remove preset shortest_path query.
        Currenetly, only empty query is supported.
        """
        argv = self.argv(param, 0, 0)
        query = self.get_types_class('preset_query')([], [])
        result = self.client.remove_shortest_path_query(self.cluster, query)
        if not result:
            print "Failed"

    def do_get_shortest_path(self, param):
        """Syntax: get_shortest_path src_node dst_node [max_hop]
        Calculates the shortest path from src_node to dst_node.
        """
        argv = self.argv(param, 2, 3)
        src_node = argv[0]
        dst_node = argv[1]
        max_hop = sys.maxint
        if len(argv) == 3:
            max_hop = int(argv[2])
        query = self.get_types_class('preset_query')([], [])
        req = self.get_types_class('shortest_path_query')(src_node, dst_node, max_hop, query)
        nodes = self.client.get_shortest_path(self.cluster, req)
        for node in nodes:
            print node

    def do_update_index(self, param):
        """Syntax: update_index
        Updates the index.
        You cannot use this method in distributed configuration.
        """
        argv = self.argv(param, 0, 0)
        result = self.client.update_index(self.cluster)
        if not result:
            print "Failed"

    def do_get_node(self, param):
        """Syntax: get_node node_id
        Get node information.
        """
        argv = self.argv(param, 1, 1)
        node_id = str(argv[0])
        info = self.client.get_node(self.cluster, node_id)
        print "Properties:"
        for key in info.p:
            print "  %s: %s" % (key, info.p[key])
        print "In-Edges:"
        print "  %s" % str(info.in_edges)
        print "Out-Edges:"
        print "  %s" % str(info.out_edges)

    def do_get_edge(self, param):
        """Syntax: get_edge edge_id [from_node_id]
        Get edge information.
        from_node_id is mandatory when in distributed mode.
        """
        argv = self.argv(param, 1, 2)
        edge_id = long(argv[0])
        from_node_id = "0"
        if len(argv) == 2:
            from_node_id = str(argv[1])
        info = self.client.get_edge(self.cluster, from_node_id, edge_id)
        print "Properties:"
        for key in info.p:
            print "  %s: %s" % (key, info.p[key])
        print "Source     : %s" % str(info.source)
        print "Destination: %s" % str(info.target)

    def argv2property(self, argv):
        if len(argv) % 2 != 0:
            raise ValueError, "value for the last property is missing"

        prop_values = {}
        for i in range(len(argv) / 2):
            prop_values[str(argv[i*2])] = str(argv[i*2+1])
        return prop_values

class AnomalyShell(AbstractGenericShell):
    @staticmethod
    def engine_name():
        return 'anomaly'

    def do_clear_row(self, param):
        """Syntax: clear_row row_id
        Clear the specified row.
        """
        argv = self.argv(param, 1, 1)
        row_id = argv[0]
        result = self.client.clear_row(self.cluster, row_id)
        if not result:
            print "Failed"

    def do_add(self, param):
        """Syntax: add datum_key datum_value [datum_key datum_value ...]
        Add a point.
        """
        argv = self.argv(param, 2)
        d = self.argv2datum(argv)
        (row_id, score) = self.client.add(self.cluster, d)
        print "Row ID: %s" % row_id
        print "Score: %g" % score

    def do_update(self, param):
        """Syntax: update row_id datum_key datum_value [datum_key datum_value ...]
        Update a point.
        """
        argv = self.argv(param, 3)
        row_id = argv[0]
        d = self.argv2datum(argv[1:])
        self.verbose("update ID: %s" % row_id)
        self.verbose("  datum = %s" % d.__dict__)
        score = self.client.update(self.cluster, row_id, d)
        print "Score: %g" % score

    def do_calc_score(self, param):
        """Syntax: calc_score datum_key datum_value [datum_key datum_value ...]
        Calculate an anomaly measure value without adding a point.
        """
        argv = self.argv(param, 2)
        d = self.argv2datum(argv)
        score = self.client.calc_score(self.cluster, d)
        print "Score: %g" % score

    def do_get_all_rows(self, param):
        """Syntax: get_all_rows
        Returns all rows. Note that converted rows will not be displayed.
        """
        argv = self.argv(param, 0, 0)
        rows = self.client.get_all_rows(self.cluster)
        for row in rows:
            print row

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Jubatus Interactive Shell Environment', add_help=False)

    # pre-load external scripts
    parser.add_argument('--load', '-l', type=str, default=None, action='append', dest='loads',
                        help='preload external shell provider (for expert users only)')
    (args, _) = parser.parse_known_args()

    if args.loads is not None:
        for load_file in args.loads:
            execfile(load_file)

    # arguments
    parser.add_argument('--host',      '-H', type=str, default='127.0.0.1',
                        help='hostname or IP address of the server or keeper')
    parser.add_argument('--port',      '-P', type=int, default=9199,
                        help='port number of the server or keeper')
    parser.add_argument('--cluster',   '-C', type=str, default='',
                        help='cluster name (only required when in distributed mode)')
    parser.add_argument('--engine',    '-e', type=str, default=None, choices=JubaShell.get_shells().keys(),
                        help='type of the server; usually auto-detected')
    parser.add_argument('--command',   '-c', type=str, default=None,
                        help='run one-shot command instead of interactive shell')
    parser.add_argument('--prompt',    '-p', type=str, default=None,
                        help='use customized shell prompt')
    parser.add_argument('--keepalive', '-k',           default=False, action='store_true',
                        help='use persistent connection; recommended for servers with timeout disabled')
    parser.add_argument('--verbose',   '-v',           default=False, action='store_true',
                        help='turn on verbose mode by default')
    parser.add_argument('--help',      '-h',           default=False, action='store_true',
                        help='display usage of this command')
    parser.add_argument('script',            type=str, default=None, nargs='?',
                        help='execute the jubash script instead of interactive shell')
    args = parser.parse_args()

    if args.help:
        parser.print_help()
        sys.exit(1)

    try:
        shell = JubaShell.get(args.host, args.port, args.cluster, args.engine, args.verbose, args.keepalive, args.prompt)
    except JubaShellDetectionFailedError as e:
        print e.message
        sys.exit(1)

    if args.script:
        retval = True
        for line in open(args.script, 'r'):
            line = line.rstrip()
            if line and not line.startswith('#'):
                retval = shell.run(line)
        sys.exit(0 if retval else 1)

    if args.command:
        shell.run(args.command)
    else:
        shell.start()
