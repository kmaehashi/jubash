#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
  _________         ___
  \____   _|       | /             ___I_I___
      |  |         | |             \__^ ^__/        ____
      |  |         | | ___    ___  __ | |          / __/
      |  | |-|  |-|| |/   \  /   \| | | | |^|  |^|| (__
      |  | | |  | ||    ^  ||  ^    | | | | |  | | \__ \
      |  | | \_/  ||    O   || O    | | |_| \_/  | ___) |
      |  |  \__/|_||_|\___/  \___/|_| |__/ \__/|_| \___/
      | /
     / /
    |/

Jubash - Jubatus Shell Environment
Copyright Â© 2012-2013 Kenichi Maehashi. All rights reserved.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License version 2.1 as published by the Free Software Foundation.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
'''

import sys
import cmd
import shlex
import optparse
import re
import json
import msgpackrpc
import subprocess

###############################################################################
# Extended framework of standard cmd.Cmd class, with better completion and
# argument type validations.
###############################################################################

class ExtendedCmd(cmd.Cmd, object):
    def parseline(self, line):
        line = line.strip()
        if not line:
            return None, None, line
        elif line[0] == '?':
            line = 'help ' + line[1:]
        elif line[0] == '!':
            if hasattr(self, 'do_shell'):
                line = 'shell ' + line[1:]
            else:
                return None, None, line
        i, n = 0, len(line)
        while i < n and line[i] in self.identchars: i = i+1
        cmd, arg = line[:i], line[i:].strip()
        return cmd, arg, line

    def complete(self, text, state):
        result = super(ExtendedCmd, self).complete(text, state)
        if len(self.completion_matches) == 1:
            return self.completion_matches[state] + ' ' if state == 0 else None
        return result

class ArgumentType(object):
    def convert(self, args):
        raise NotImplementedError

    def min_max(self):
        raise NotImplementedError

class ArgumentRequirement(object): pass

class Mandatory(ArgumentRequirement):
    def __init__(self, t):
        self.t = t

    def convert(self, args):
        if issubclass(self.t, ArgumentType):
            return self.t().convert(args)
        else:
            return (1, self.t(args[0]))

    def min_max(self):
        if issubclass(self.t, ArgumentType):
            return self.t().min_max()
        else:
            return (1, 1)

class Optional(Mandatory):
    def convert(self, args):
        if len(args) == 0:
            return (0, None)
        return super(Optional, self).convert(args)

    def min_max(self):
        return (0, super(Optional, self).min_max()[1])

def Arguments(*expected_types):
    def wrap_function(func):
        assert func.func_code.co_argcount == len(expected_types) + 1

        def wrapper(self, line):
            params = shlex.split(line)
            types = []
            (min_count, max_count) = (0, 0)

            for t in expected_types:
                if not isinstance(t, ArgumentRequirement):
                    t = Mandatory(t)
                types.append(t)
                (t_min, t_max) = t.min_max()
                min_count += t_min
                if t_max is None:
                    max_count = None
                elif max_count is not None:
                    max_count += t_max

            params_len = len(params)
            if params_len < min_count:
                raise ValueError('Too few arguments (%d required at least, only got %d)' % (min_count, params_len))
            if max_count is not None and max_count < params_len:
                raise ValueError('Too many arguments (%d required at most, got %d)' % (max_count, params_len))

            index = 0
            argv = []
            for t in types:
                try:
                    (consumed, value) = t.convert(params[index:])
                except ValueError as e:
                    raise ValueError('argument %d: %s' % (index + 1, str(e)))
                argv.append(value)
                index += consumed
            return func(self, *argv)
        wrapper.__doc__ = func.__doc__
        return wrapper
    return wrap_function


###############################################################################
# Base class for shells of each engine.
###############################################################################
class JubaShell(ExtendedCmd):
    """
    Base class of Jubatus shell
    """
    def __init__(self, host, port, cluster, verbose_mode, keepalive, prompt_format):
        super(JubaShell, self).__init__()

        # Server configuration
        self.client = None
        self.host = host
        self.port = port
        self.cluster = cluster
        self.keepalive = keepalive
        self.timeout = 10

        # Shell configuration
        self.verbose_mode = verbose_mode
        self.prompt_format = prompt_format

        # Help configuration
        self.doc_header = "Commands:"
        self.undoc_header = "Commands (no help available):"
        self.misc_header = "Documents:"
        self.nohelp = "No help available for %s."

        # Register aliases
        self.register_alias('EOF', 'do_exit')
        self.register_alias('ls', 'do_help')
        self.register_alias('shell', 'shell_command')

    @staticmethod
    def engine_name():
        """
        Return the name of the engine (e.g., `classifier`).
        You must override this in subclasses.
        """
        raise NotImplementedError

    def start(self):
        """
        Start the interactive shell.
        """
        self.update_prompt()
        while True:
            try:
                self.connect()
                self.cmdloop()
                return
            except ValueError as e:
                print "Invalid argument: %s; use `help` command for details" % str(e)
            except msgpackrpc.error.RPCError as e:
                print "RPC Error: " + str(e)
            except KeyboardInterrupt: # trap Ctrl-C
                print
            except JubaShellFatalError as e:
                print "Fatal Error: " + str(e)
                break
            except self.get_common_class(['client', 'InterfaceMismatch']):
                print "Interface Mismatch Error detected.\n" + \
                    "This error occured because either your Jubatus Python client " + \
                    "library is not compatible with the server you are connecting " + \
                    "to, or using incompatible shell (for example, using Classifier " + \
                    "shell against Recommender server.)"
                break
            finally:
                self.disconnect()

    def run(self, command):
        """
        Run the given single command.
        """
        try:
            self.connect()
            print ">> %s" % command
            stop = self.onecmd(command)
            return True
        except ValueError as e:
            print "Invalid argument: %s" % str(e)
            return False
        except msgpackrpc.error.RPCError as e:
            print "RPC Error: " + str(e)
            return False
        except KeyboardInterrupt: # trap Ctrl-C
            print "Interrupted."
            return False
        except BaseException as e:
            print "Fatal Error: " + str(e)
            return False
        finally:
            self.disconnect()

    def postcmd(self, stop, line):
        if not self.keepalive:
            self.disconnect()
            self.connect()
        return stop

    def emptyline(self):
        """
        By default, empty line causes the previous command to run again.
        This overrides the default handler for emptyline so it behaves like the usual shell.
        """
        pass

    def default(self, line):
        print "Unknown command: %s" % line
        print "Type `help` for commands available."

    def shell_command(self, param):
        subprocess.call(param, shell=True)

    def verbose(self, msg):
        if self.verbose_mode:
            print msg

    def register_alias(self, alias, name):
        """
        Register alias function to the method.
        Aliases are not listed by `help` command.
        """
        self.__dict__['do_' + alias] = getattr(self, name)

    def update_prompt(self):
        """
        Call this to update the shell prompt upon reconnection etc.
        """
        self.prompt = self.prompt_format % {'engine': self.engine_name(), 'cluster': self.cluster, 'host': self.host, 'port': str(self.port)}

    #################################################################
    # Built-in commands
    #################################################################
    @Arguments()
    def do_exit(self):
        """Syntax: exit
        Exit the shell. You can also use EOF (Ctrl-D).
        """
        print
        return True

    @Arguments(str, int, Optional(str))
    def do_connect(self, host, port, cluster):
        """Syntax: connect host port [cluster]
        Connect to the specified host, port and cluster (optional).
        """
        if cluster is None:
            cluster = self.cluster
        self.disconnect()

        print "Connecting to <%s>@%s:%d..." % (cluster, host, port)
        self.host = host
        self.port = port
        self.cluster = cluster
        self.connect()
        self.update_prompt()

    @Arguments()
    def do_reconnect(self):
        """Syntax: reconnect
        Reconnects to the current server.
        """
        self.connect()

    @Arguments()
    def do_verbose(self):
        """Syntax: verbose
        Toggles the verbose mode.
        """
        self.verbose_mode = not self.verbose_mode
        if self.verbose_mode:
            print "Verbose mode turned on."
        else:
            print "Verbose mode turned off."

    @Arguments()
    def do_keepalive(self):
        """Syntax: keepalive
        Toggle the keepalive mode.
        """
        self.keepalive = not self.keepalive
        if self.keepalive:
            print "Keepalive is enabled"
        else:
            print "Keepalive is disabled"

    @Arguments()
    def do_get_timeout(self):
        """Syntax: get_timeout
        Display the client-side timeout.
        """
        print("Timeout: %d seconds" % self.client.client._timeout)

    @Arguments(int)
    def do_set_timeout(self, timeout):
        """Syntax: set_timeout seconds
        Set the client-side timeout in seconds.
        """
        self.timeout = timeout
        self.client.client._timeout = self.timeout

    def help_help(self):
        """
        Help for help command.
        """
        print "Display list of commands or description of the given command"

    #################################################################
    # RPC connection handling
    #################################################################
    def connect(self):
        """
        Discard the current connection (if connected) and create new client instance.
        Note that TCP connection will not be established until RPC method is called.
        """
        if self.is_connected():
            self.disconnect()
        self.client = self.get_client(self.host, self.port, self.cluster, self.timeout)

    def disconnect(self):
        """
        Disconnects from the server (if connected).
        """
        if self.is_connected():
            self.client.client.close()
            self.client = None

    def is_connected(self):
        """
        `is_connected` returns True, if the client can be closed.
        The TCP connection may already be closed.
        """
        return self.client is not None

    #################################################################
    # Accessor to client classes
    #################################################################
    def get_client(self, host, port, cluster, timeout):
        """
        Get client instance for given host and port.
        """
        c = ['jubatus', self.engine_name(), 'client', self._snake2pythonic(self.engine_name())]
        try:
            client_class = self.get_class('.'.join(c))
            return client_class(host, port, cluster, timeout)
        except ImportError, AttributeError:
            raise JubaShellFatalError(\
                'Failed to create the client instance.\n' + \
                'Maybe you have not installed Jubatus Python client library or the installed one is incompatible with this version of Jubash.')

    def get_types_class(self, name):
        """
        Get class for the data structure of given name.
        """
        if name.lower() == 'datum':
            c = ['jubatus', 'common', 'Datum']
        else:
            c = ['jubatus', self.engine_name(), 'types', self._snake2pythonic(name)]
        try:
            return self.get_class('.'.join(c))
        except ImportError, AttributeError:
            raise JubaShellFatalError(\
                'Failed to create the data structure instance.\n' + \
                'Maybe you have not installed Jubatus Python client library or the installed one is incompatible with this version of Jubash.')

    @classmethod
    def get_common_class(self, names):
        if not isinstance(names, list):
            names = [names]
        try:
            return self.get_class('.'.join(['jubatus', 'common'] + names))
        except ImportError, AttributeError:
            raise JubaShellFatalError(\
                'Failed to create the common data structure instance.\n' + \
                'Maybe you have not installed Jubatus Python client library or the installed one is incompatible with this version of Jubash.')

    @staticmethod
    def _snake2pythonic(name):
        return ''.join(map(str.capitalize, name.split('_')))

    #################################################################
    # Utilities
    #################################################################
    @staticmethod
    def get_class(name):
        """
        Dynamically import and return a class of given name.
        """
        levels = name.split('.')
        (package, module, basename) = (levels[0], '.'.join(levels[:-1]), levels[-1])
        return getattr(__import__(module, fromlist=[package]), basename)

    @staticmethod
    def get_shells():
        shells = {}
        work = [JubaShell]
        while work:
            parent = work.pop()
            for child in parent.__subclasses__():
                if child not in shells.values():
                    work.append(child)
                    try:
                        name = child.engine_name()
                    except NotImplementedError: # child is an abstract class
                        continue
                    shells[name] = child
        return shells

    @staticmethod
    def get(host, port, cluster, engine, verbose_mode, keepalive, prompt_format):
        """
        Get shell for the specified parameter.
        """
        if not engine:
            # guess the engine from get_status
            client = msgpackrpc.Client(msgpackrpc.Address(host, port))
            try:
                results = client.call('get_status', cluster)
                if len(results) == 0:
                    raise JubaShellDetectionFailedError('Got empty reply from server', host, port)
            except msgpackrpc.error.RPCError as e:
                raise JubaShellDetectionFailedError('RPC error (%s) while requesting get_status to server' % str(e), host, port)
            finally:
                client.close()
            result1 = results.popitem()[1]
            if not 'PROGNAME' in result1:
                raise JubaShellDetectionFailedError('No program name returned from server', host, port)
            engine = result1['PROGNAME']
            if engine.startswith('juba'):
                engine = engine[4:]
        shells = JubaShell.get_shells()
        if engine in shells.keys():
            return shells[engine](host, port, cluster, verbose_mode, keepalive, prompt_format)
        print "Warning: Shell for '%s' not found, falling back to the generic shell." % engine
        return GenericShell(host, port, cluster, verbose_mode, keepalive, prompt_format)

    @staticmethod
    def computil_argnum(text, line, begidx, endidx):
        return len(JubaShell.argv(line[0:begidx],0)) - 1

    @staticmethod
    def computil_filter(text, candidates):
        return [x for x in candidates if x.startswith(text)]

class TProperty(ArgumentType):
    def convert(self, args):
        if len(args)  % 2 != 0:
            raise ValueError("value for the last property key (%s) is missing" % args[len(args) - 1])
        p = {}
        for i in xrange(len(args) / 2):
            p[args[i*2]] = args[i*2+1]
        return (len(args), p)

    def min_max(self):
        return (2, None)

class TDatum(ArgumentType):
    def convert(self, args):
        if len(args) % 2 != 0:
            raise ValueError("value for the last datum key (%s) is missing" % args[len(args) - 1])

        d = JubaShell.get_common_class('Datum')()
        for i in xrange(len(args) / 2):
            feat_key = args[i*2]
            feat_val = args[i*2+1]
            try:
                d.add_number(feat_key, float(feat_val))
            except ValueError:
                d.add_string(feat_key, feat_val)
        return (len(args), d)

    def min_max(self):
        return (0, None)

def TMultiDatum(count):
    class TOffsetDatum(TDatum):
        def convert(self, args):
            if '|' not in args:
                raise ValueError('insufficient number of datum')
            (consumed, value) = super(TOffsetDatum, self).convert(args[:args.index('|')])
            return (consumed + 1, value)

        def min_max(self):
            return (1, None)

    return [TOffsetDatum] * (count - 1) + [TDatum]

###############################################################################
# Errors
###############################################################################

class JubaShellDetectionFailedError(Exception):
    def __init__(self, msg, host, port):
        super(JubaShellDetectionFailedError, self).__init__('Failed to auto-detect the engine: ' + msg + ' (%s:%d)' % (host, port))

class JubaShellFatalError(Exception):
    def __init__(self, *args, **kwargs):
        super(JubaShellFatalError, self).__init__(*args, **kwargs)

###############################################################################
# Shell Implementations
###############################################################################

class AbstractGenericShell(JubaShell):
    """
    Generic implementation of the engine-specific shell that implements
    get_config, save, load, clear and get_status.
    This class cannot be instantiated.

    In most cases, you should inherit this class, rather than creating
    your own one from scratch for your engine.
    """

    @Arguments()
    def do_get_config(self):
        """Syntax: get_config
        Display algorithm and converter configuration set in server.
        """
        config = self.client.get_config()
        print json.dumps(json.loads(config), sort_keys=True, indent=4)

    @Arguments(str)
    def do_save(self, model_id):
        """Syntax: save model_id
        Save the model.
        """
        result = self.client.save(model_id)
        if not result:
            print "Failed"

    @Arguments()
    def do_clear(self):
        """Syntax: clear
        Clear the model.
        """
        result = self.client.clear()
        if not result:
            print "Failed"

    @Arguments(str)
    def do_load(self, model_id):
        """Syntax: load model_id
        Load the given model.
        """
        result = self.client.load(model_id)
        if not result:
            print "Failed"

    @Arguments()
    def do_get_status(self):
        """Syntax: get_status
        Displays status of servers.
        """
        status = self.client.get_status()
        self.print_status(status)

    def print_status(self, status):
        """
        Pretty-print the status structure.
        """
        for server_port in status:
            server_stat = status[server_port]
            print "Server %s:%s" % tuple(server_port.split('_'))
            for key in sorted(server_stat.keys()):
                print "  %s: %s" % (key, server_stat[key])

class GenericShell(AbstractGenericShell):
    """
    Shell for unknown server engines.
    """
    @staticmethod
    def engine_name():
        return 'generic'

    def get_client(self, host, port, cluster, timeout):
        return GenericShell.GenericClient(host, port, cluster, timeout)

    class GenericClient():
        def __init__(self, host, port, cluster, timeout):
            self.name = cluster
            address = msgpackrpc.Address(host, port)
            self.client = msgpackrpc.Client(address, timeout=timeout)

        def get_config(self):
            return self.client.call('get_config', self.name)

        def save(self, model_id):
            return self.client.call('save', self.name, model_id)

        def load(self, model_id):
            return self.client.call('load', self.name, model_id)

        def clear(self):
            return self.client.call('clear', self.name)

        def get_status(self):
            return self.client.call('get_status', self.name)

class ClassifierShell(AbstractGenericShell):
    cached_labels = set()

    @staticmethod
    def engine_name():
        return 'classifier'

    @Arguments(str, TDatum)
    def do_train(self, label, d):
        """Syntax: train label datum_key datum_value [datum_key datum_value ...]
        Trains the model with given label and datum.
        Bulk training is not supported on the command line.
        """
        self.verbose("train: label = %s" % label)
        self.verbose("  datum = %s" % d.__dict__)
        result = self.client.train([(label, d)])
        if result != 1:
            print "Failed"
        self.cached_labels.add(label)

    def complete_train(self, text, line, begidx, endidx):
        argnum = self.computil_argnum(text, line, begidx, endidx)
        if argnum == 0:
            return self.computil_filter(text, self.cached_labels)

    @Arguments(TDatum)
    def do_classify(self, d):
        """Syntax: classify datum_key datum_value [datum_key datum_value ...]
        Classify the given datum.
        Bulk classification is not supported on the command line.
        """
        self.verbose("classify:")
        self.verbose("  datum = %s" % d.__dict__)
        results = self.client.classify([d])[0]
        results.sort(key=lambda e: e.score, reverse=True)
        for result in results:
            print "%s: %s" % (result.label, str(result.score))
            self.cached_labels.add(result.label)

class RegressionShell(AbstractGenericShell):
    @staticmethod
    def engine_name():
        return 'regression'

    @Arguments(float, TDatum)
    def do_train(self, label, d):
        """Syntax: train label datum_key datum_value [datum_key datum_value ...]
        Trains the model with given label and datum.
        Bulk training is not supported on the command line.
        """
        self.verbose("train: label = %s" % label)
        self.verbose("  datum = %s" % d.__dict__)
        result = self.client.train([(label, d)])
        if result != 1:
            print "Failed"

    @Arguments(TDatum)
    def do_estimate(self, d):
        """Syntax: estimate datum_key datum_value [datum_key datum_value ...]
        Estimate the value for the given datum.
        Bulk estimation is not supported on the command line.
        """
        self.verbose("estimate:")
        self.verbose("  datum = %s" % d.__dict__)
        result = self.client.estimate([d])[0]
        print "%s" % str(result)

class RecommenderShell(AbstractGenericShell):
    max_results = 100

    @staticmethod
    def engine_name():
        return 'recommender'

    @Arguments(str)
    def do_clear_row(self, row_id):
        """Syntax: clear_row row_id
        Clear the specified row.
        """
        result = self.client.clear_row(row_id)
        if not result:
            print "Failed"

    @Arguments(str, TDatum)
    def do_update_row(self, row_id, d):
        """Syntax: update_row row_id datum_key datum_value [datum_key datum_value ...]
        Update or insert a new row.
        """
        self.verbose("update_row ID: %s" % row_id)
        self.verbose("  datum = %s" % d.__dict__)
        result = self.client.update_row(row_id, d)
        if not result:
            print "Failed"

    @Arguments(str)
    def do_complete_row_from_id(self, row_id):
        """Syntax: complete_row_from_id id
        Complete row from the given ID.
        """
        d = self.client.complete_row_from_id(row_id)
        print(d)

    @Arguments(TDatum)
    def do_complete_row_from_datum(self, d):
        """syntax: complete_row_from_datum datum_key datum_value [datum_key datum_value ...]
        Complete row from the given datum.
        """
        d = self.client.complete_row_from_datum(d)
        print(d)

    @Arguments(str)
    def do_similar_row_from_id(self, row_id):
        """Syntax: similar_row_from_id id
        Similar row from the given ID.
        """
        results = self.client.similar_row_from_id(row_id, self.max_results)
        self.print_similar_result(results)

    @Arguments(TDatum)
    def do_similar_row_from_datum(self, d):
        """syntax: similar_row_from_datum datum_key datum_value [datum_key datum_value ...]
        Similar row from the given datum.
        """
        results = self.client.similar_row_from_datum(d, self.max_results)
        self.print_similar_result(results)

    @Arguments(str)
    def do_decode_row(self, row_id):
        """Syntax: decode_row id
        Decode the row of given ID.
        """
        d = self.client.decode_row(row_id)
        print(d)

    @Arguments()
    def do_get_all_rows(self):
        """Syntax: get_all_rows
        Returns all rows. Note that converted rows will not be displayed.
        """
        rows = self.client.get_all_rows()
        for row in rows:
            print row

    @Arguments(*TMultiDatum(2))
    def do_calc_similarity(self, lhs, rhs):
        """Syntax: calc_similarity datum1_key datum1_value ... | datum2_key datum2_value ...
        Calculates similarity between two datum.
        Separate two datum records with a bar ('|').
        """
        self.verbose("lhs: " + str(lhs))
        self.verbose("rhs: " + str(rhs))
        similarity = self.client.calc_similarity(lhs, rhs)
        print similarity


    @Arguments(TDatum)
    def do_calc_l2norm(self, d):
        """Syntax: calc_l2norm datum_key datum_value ...
        Calculates L2 norm for the given datum.
        """
        print(d)
        l2norm = self.client.calc_l2norm(d)
        print l2norm

    @Arguments(Optional(int))
    def do_max_results(self, new_value):
        """Syntax: max_results [new_value]
        Displays or changes the maximum number of results for similar_row_from_{id,datum}.
        """
        if new_value is None:
            print self.max_results
        else:
            self.max_results = new_value

    def print_similar_result(self, results):
        results.sort(key=lambda e: e[1], reverse=True)
        for result in results:
            print "%s: %g" % (result[0], result[1])

class StatShell(AbstractGenericShell):
    @staticmethod
    def engine_name():
        return 'stat'

    @Arguments(str, float)
    def do_push(self, key, value):
        """Syntax: push key value
        Add value for the specified key.
        """
        result = self.client.push(key, value)
        if not result:
            print "Failed"

    @Arguments(str)
    def do_sum(self, key):
        """Syntax: sum key
        Get sum for the specified key.
        """
        print self.client.sum(key)

    @Arguments(str)
    def do_stddev(self, key):
        """Syntax: stddev key
        Get stddev for the specified key.
        """
        print self.client.stddev(key)

    @Arguments(str)
    def do_max(self, key):
        """Syntax: max key
        Get max for the specified key.
        """
        print self.client.max(key)

    @Arguments(str)
    def do_min(self, key):
        """Syntax: min key
        Get min for the specified key.
        """
        print self.client.min(key)

    @Arguments(str)
    def do_entropy(self, key):
        """Syntax: entropy key
        Get entropy for the specified key.
        """
        print self.client.entropy(key)

    @Arguments(str, int, float)
    def do_moment(self, key, n, c):
        """Syntax: moment key n c
        Get n-th moment about c of values in the specified key.
        """
        print self.client.moment(key, n, c)

class GraphShell(AbstractGenericShell):
    @staticmethod
    def engine_name():
        return 'graph'

    @Arguments()
    def do_create_node(self):
        """Syntax: create_node
        Create node.
        """
        node_id = self.client.create_node()
        print "%s" % node_id

    @Arguments(str)
    def do_remove_node(self, node_id):
        """Syntax: remove_node node_id
        Remove the specified node.
        """
        result = self.client.remove_node(node_id)
        if not result:
            print "Failed"

    @Arguments(str, TProperty)
    def do_update_node(self, node_id, prop):
        """Syntax: update_node node_id [property_key property_value ...]
        Update node.
        """
        result = self.client.update_node(node_id, prop)
        if not result:
            print "Failed"

    @Arguments(str, str, Optional(TProperty))
    def do_create_edge(self, from_node_id, to_node_id, prop):
        """Syntax: create_edge from_node to_node [property_key property_value ...]
        Create edge.
        """
        info = self.get_types_class('edge')(prop, from_node_id, to_node_id)
        result = self.client.create_edge(from_node_id, info)
        print "Edge ID: %s" % str(result)

    @Arguments(long, str, str, Optional(TProperty))
    def do_update_edge(self, edge_id, from_node_id, to_node_id, prop):
        """Syntax: update_edge edge_id from_node to_node [property_key property_value ...]
        Update edge.
        """
        info = self.get_types_class('edge')(prop, from_node_id, to_node_id)
        result = self.client.update_edge(from_node_id, edge_id, info)
        if not result:
            print "Failed"

    @Arguments(long, Optional(str))
    def do_remove_edge(self, edge_id, from_node_id):
        """Syntax: remove_edge edge_id [from_node]
        Remove the specified edge.
        from_node is mandatory when in distributed mode.
        """
        if from_node_id is None:
            from_node_id = ""
        result = self.client.remove_edge(from_node_id, edge_id)
        if not result:
            print "Failed"

    @Arguments(str, int)
    def do_get_centrality(self, node_id, c_type):
        """Syntax: get_centrality node_id [type]
        Calculate centrality for the node.
        "type" is 0 (PageRank) by default.
        Currenetly, only empty query is supported.
        """
        if c_type is None:
            c_type = 0
        query = self.get_types_class('preset_query')([], [])
        centrality = self.client.get_centrality(node_id, c_type, query)
        print "%s" % str(centrality)

    @Arguments()
    def do_add_centrality_query(self):
        """Syntax: add_centrality_query
        Preset centrality query.
        Currenetly, only empty query is supported.
        """
        query = self.get_types_class('preset_query')([], [])
        result = self.client.add_centrality_query(query)
        if not result:
            print "Failed"

    @Arguments()
    def do_add_shortest_path_query(self):
        """Syntax: add_shortest_path_query
        Preset shortest_path query.
        Currenetly, only empty query is supported.
        """
        query = self.get_types_class('preset_query')([], [])
        result = self.client.add_shortest_path_query(query)
        if not result:
            print "Failed"

    @Arguments()
    def do_remove_centrality_query(self):
        """Syntax: remove_centrality_query
        Remove preset centrality query.
        Currenetly, only empty query is supported.
        """
        query = self.get_types_class('preset_query')([], [])
        result = self.client.remove_centrality_query(query)
        if not result:
            print "Failed"

    @Arguments()
    def do_remove_shortest_path_query(self):
        """Syntax: remove_shortest_path_query
        Remove preset shortest_path query.
        Currenetly, only empty query is supported.
        """
        query = self.get_types_class('preset_query')([], [])
        result = self.client.remove_shortest_path_query(query)
        if not result:
            print "Failed"

    @Arguments(str, str, Optional(int))
    def do_get_shortest_path(self, src_node, dst_node, max_hop):
        """Syntax: get_shortest_path src_node dst_node [max_hop]
        Calculates the shortest path from src_node to dst_node.
        """
        if max_hop is None:
            max_hop = sys.maxint
        query = self.get_types_class('preset_query')([], [])
        req = self.get_types_class('shortest_path_query')(src_node, dst_node, max_hop, query)
        nodes = self.client.get_shortest_path(req)
        for node in nodes:
            print node

    @Arguments()
    def do_update_index(self):
        """Syntax: update_index
        Updates the index.
        You cannot use this method in distributed configuration.
        """
        result = self.client.update_index()
        if not result:
            print "Failed"

    @Arguments(str)
    def do_get_node(self, node_id):
        """Syntax: get_node node_id
        Get node information.
        """
        info = self.client.get_node(node_id)
        print "Properties:"
        for key in info.p:
            print "  %s: %s" % (key, info.p[key])
        print "In-Edges:"
        print "  %s" % str(info.in_edges)
        print "Out-Edges:"
        print "  %s" % str(info.out_edges)

    @Arguments(long, Optional(str))
    def do_get_edge(self, edge_id, from_node_id):
        """Syntax: get_edge edge_id [from_node_id]
        Get edge information.
        from_node_id is mandatory when in distributed mode.
        """
        if from_node_id is None:
            from_node_id = "0"
        info = self.client.get_edge(from_node_id, edge_id)
        print "Properties:"
        for key in info.p:
            print "  %s: %s" % (key, info.p[key])
        print "Source     : %s" % str(info.source)
        print "Destination: %s" % str(info.target)

class AnomalyShell(AbstractGenericShell):
    @staticmethod
    def engine_name():
        return 'anomaly'

    @Arguments(str)
    def do_clear_row(self, row_id):
        """Syntax: clear_row row_id
        Clear the specified row.
        """
        result = self.client.clear_row(row_id)
        if not result:
            print "Failed"

    @Arguments(TDatum)
    def do_add(self, d):
        """Syntax: add datum_key datum_value [datum_key datum_value ...]
        Add a point.
        """
        (row_id, score) = self.client.add(d)
        print "Row ID: %s" % row_id
        print "Score: %g" % score

    @Arguments(str, TDatum)
    def do_update(self, row_id, d):
        """Syntax: update row_id datum_key datum_value [datum_key datum_value ...]
        Update a point.
        """
        self.verbose("update ID: %s" % row_id)
        self.verbose("  datum = %s" % d.__dict__)
        score = self.client.update(row_id, d)
        print "Score: %g" % score

    @Arguments(str, TDatum)
    def do_overwrite(self, row_id, d):
        """Syntax: overwrite row_id datum_key datum_value [datum_key datum_value ...]
        Overwrite the point.
        """
        self.verbose("overwrite ID: %s" % row_id)
        self.verbose("  datum = %s" % d)
        score = self.client.overwrite(row_id, d)
        print "Score: %g" % score

    @Arguments(TDatum)
    def do_calc_score(self, d):
        """Syntax: calc_score datum_key datum_value [datum_key datum_value ...]
        Calculate an anomaly measure value without adding a point.
        """
        score = self.client.calc_score(d)
        print "Score: %g" % score

    @Arguments()
    def do_get_all_rows(self):
        """Syntax: get_all_rows
        Returns all rows. Note that converted rows will not be displayed.
        """
        rows = self.client.get_all_rows()
        for row in rows:
            print row

class ClusteringShell(AbstractGenericShell):
    @staticmethod
    def engine_name():
        return 'clustering'

    @Arguments(TDatum)
    def do_push(self, d):
        """Syntax: push datum_key datum_value [...]
        Add a point. Bulk request is not supported.
        """
        if not self.client.push([d]):
            print "Failed"

    @Arguments()
    def do_get_revision(self):
        """Syntax: get_revision
        Return the revision of the cluster.
        """
        print self.client.get_revision()

    @Arguments()
    def do_get_core_members(self):
        """Syntax: get_core_members
        Return the coreset of the cluster.
        """
        result = self.client.get_core_members()
        for cluster in result:
            print "[Cluster]"
            for member in cluster:
                print "  Weight: %g" % (member.weight)
                print "    Datum: %s" % str(member.point)

    @Arguments()
    def do_get_k_center(self):
        """Syntax: get_k_center
        Returns k cluster centers.
        """
        result = self.client.get_k_center()
        for cluster in result:
            print "[Cluster]"
            print "  Datum: %s" % str(cluster)

    @Arguments(TDatum)
    def do_get_nearest_center(self, d):
        """Syntax: get_nearest_center datum_key datum_value [...]
        Returns nearest cluster center without adding point to cluster.
        """
        result = self.client.get_nearest_center(d)
        print str(result)

    @Arguments(TDatum)
    def do_get_nearest_members(self, d):
        """Syntax: get_nearest_members datum_key datum_value [...]
        Returns nearest summary of cluster(coreset) from point.
        """
        result = self.client.get_nearest_members(d)
        for member in result:
            print "Weight: %g" % (member.weight)
            print "  Datum: %s" % str(member.point)

class NearestNeighborShell(AbstractGenericShell):
    max_results = 100

    @staticmethod
    def engine_name():
        return 'nearest_neighbor'

    @Arguments(str, TDatum)
    def do_set_row(self, row_id, d):
        """Syntax: set_row row_id datum_key datum_value [...]
        Updates the row whose id is row_id with given datum.
        """
        result = self.client.set_row(row_id, d)
        if not result:
            print "Failed"

    @Arguments(str)
    def do_neighbor_row_from_id(self, row_id):
        """Syntax: neighbor_row_from_id row_id
        Get rows that have most similar datum to the given row ID.
        """
        result = self.client.neighbor_row_from_id(row_id, self.max_results)
        self.print_id_with_scores(result)

    @Arguments(TDatum)
    def do_neighbor_row_from_data(self, d):
        """Syntax: neighbor_row_from_data datum_key datum_value [...]
        Get rows that have most similar datum to the given datum.
        """
        result = self.client.neighbor_row_from_data(d, self.max_results)
        self.print_id_with_scores(result)

    @Arguments(str)
    def do_similar_row_from_id(self, row_id):
        """Syntax: similar_row_from_id row_id
        Get rows that have most similar datum to the given row ID.
        """
        result = self.client.similar_row_from_id(row_id, self.max_results)
        self.print_id_with_scores(result)

    @Arguments(TDatum)
    def do_similar_row_from_data(self, d):
        """Syntax: similar_row_from_data datum_key datum_value [...]
        Get rows that have most similar datum to the given datum.
        """
        result = self.client.similar_row_from_data(d, self.max_results)
        self.print_id_with_scores(result)

    @Arguments(Optional(int))
    def do_max_results(self, new_value):
        """Syntax: max_results [new_value]
        Displays or changes the maximum number of results for {neighbor,similar}_row_from_{id,data}.
        """
        if new_value is None:
            print self.max_results
        else:
            self.max_results = new_value

    def print_id_with_scores(self, result):
        for ent in result:
            print "{:<15} {:>}".format(ent.score, ent.id)

if __name__ == '__main__':
    USAGE = '''\
Jubash - Jubatus Shell Environment

Usage:
  jubash [--host HOST] [--port PORT] [--cluster CLUSTER]
         [--engine ENGINE] [--command COMMAND]
         [--keepalive] [--verbose] [--prompt PROMPT]
         [--load LOAD]
         [--help] [script ...]

Options:
  -H, --host HOST   host name or IP address of the server / proxy
                    (default: 127.0.0.1)
  -P, --port PORT   port number of the server / proxy
                    (default: 9199)
  -C, --cluster CLUSTER
                    cluster name; only required when connecting to proxy
  -e, --engine ENGINE
                    type of the server; see below for engines available
                    (default: auto-detect)
  -c, --command COMMAND
                    run one-shot command instead of interactive shell
  -p, --prompt PROMPT
                    use customized shell prompt
  -k, --keepalive
                    use persistent connection; recommended for servers
                    with timeout disabled
  -v, --verbose
                    turn on verbose mode
  -l, --load LIBRARY
                    preload external shell provider (for expert users)
  -h, --help
                    print the usage and exit
  script
                    execute shell script instead of interactive shell

Engines:
  Following engines are available:
    %(shells)s
'''

    parser = optparse.OptionParser(add_help_option=False)
    parser.error = lambda x: None

    # pre-load external scripts
    parser.add_option('--load', '-l', type='string', default=None, action='append', dest='loads')
    (args, _) = parser.parse_args()

    if args.loads is not None:
        for load_file in args.loads:
            execfile(load_file)

    # arguments
    parser.add_option('--host',      '-H', type='string', default='127.0.0.1')
    parser.add_option('--port',      '-P', type='int',    default=9199)
    parser.add_option('--cluster',   '-C', type='string', default='')
    parser.add_option('--engine',    '-e', type='string', default=None)
    parser.add_option('--command',   '-c', type='string', default=None)
    parser.add_option('--prompt',    '-p', type='string', default='[Jubatus:%(engine)s<%(cluster)s>@%(host)s:%(port)s] # ')
    parser.add_option('--keepalive', '-k',                default=False, action='store_true')
    parser.add_option('--verbose',   '-v',                default=False, action='store_true')
    parser.add_option('--help',      '-h',                default=False, action='store_true')
    (args, scripts) = parser.parse_args()

    show_help = False

    if args.port < 0 or 65535 < args.port:
        print "Error: port number out of range"
        show_help = True

    if args.help:
        show_help = True

    if show_help:
        print USAGE % {'shells': JubaShell.get_shells().keys()}
        sys.exit(1)

    try:
        shell = JubaShell.get(args.host, args.port, args.cluster, args.engine, args.verbose, args.keepalive, args.prompt)
    except JubaShellDetectionFailedError as e:
        print str(e)
        sys.exit(1)

    if len(scripts) != 0:
        for script in scripts:
            retval = True
            for line in open(script, 'r'):
                line = line.rstrip()
                if line and not line.startswith('#'):
                    retval = shell.run(line)
        sys.exit(0 if retval else 1)

    if args.command:
        shell.run(args.command)
    else:
        shell.start()
