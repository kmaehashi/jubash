#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Jubatus Shell
# @author Kenichi Maehashi

'''
  _________         ___                                  
  \____   _|       | /             ___I_I___             
      |  |         | |             \__^ ^__/        ____ 
      |  |         | | ___    ___  __ | |          / __/ 
      |  | |-|  |-|| |/   \  /   \| | | | |^|  |^|| (__  
      |  | | |  | ||    ^  ||  ^    | | | | |  | | \__ \ 
      |  | | \_/  ||    O   || O    | | |_| \_/  | ___) |
      |  |  \__/|_||_|\___/  \___/|_| |__/ \__/|_| \___/ 
      | /                                                
     / /                                                 
    |/                                                   
'''
 
import sys
import cmd, readline, shlex
import argparse
import re
import json
import msgpackrpc
import subprocess

class ExtendedCmd(cmd.Cmd, object):
    def parseline(self, line):
        line = line.strip()
        if not line:
            return None, None, line
        elif line[0] == '?':
            line = 'help ' + line[1:]
        elif line[0] == '!':
            if hasattr(self, 'do_shell'):
                line = 'shell ' + line[1:]
            else:
                return None, None, line
        i, n = 0, len(line)
        while i < n and line[i] in self.identchars: i = i+1
        cmd, arg = line[:i], line[i:].strip()
        return cmd, arg, line

    def complete(self, text, state):
        result = super(ExtendedCmd, self).complete(text, state)
        if len(self.completion_matches) == 1:
            return self.completion_matches[state] + ' ' if state == 0 else None
        return result

class JubaShell(ExtendedCmd):
    """
    Base class of Jubatus shell
    """
    def __init__(self, host, port, cluster, verbose_mode=False):
        super(JubaShell, self).__init__()

        # Server configuration
        self.host = host
        self.port = port
        self.cluster = cluster

        # Shell configuration
        self.verbose_mode = verbose_mode
        # TODO: support history management

        # Help configuration
        self.doc_header = "Commands:"
        self.undoc_header = "Commands (no help available):"
        self.misc_header = "Documents:"
        self.nohelp = "No help available for %s."

        # Register aliases
        self.register_alias('EOF', 'do_exit')
        self.register_alias('ls', 'do_help')
        self.register_alias('shell', 'shell_command')

    @staticmethod
    def engine_name():
        """
        Return the name of the engine (e.g., `classifier`).
        You must override this in subclasses.
        """
        raise NotImplementedError

    def start(self, oneshot=None):
        """
        Start the shell.
        """
        self.update_prompt()
        while True:
            try:
                if oneshot:
                    oneshot = self.precmd(oneshot)
                    stop = self.onecmd(oneshot)
                    stop = self.postcmd(stop, oneshot)
                else:
                    self.cmdloop()
                return
            except ValueError as e:
                print "Invalid argument: %s; use `help` command for details" % str(e.message)
            except msgpackrpc.error.RPCError as e:
                print "RPC Error: " + str(e.message)
            except KeyboardInterrupt: # trap Ctrl-C
                print
            finally:
                if oneshot:
                    return

    def precmd(self, line):
        self.connect(self.host, self.port, self.cluster)
        return line

    def postcmd(self, stop, line):
        self.disconnect()
        return stop

    def emptyline(self):
        """
        By default, empty line causes the previous command to run again.
        This overrides the default handler for emptyline so it behaves like the usual shell.
        """
        pass

    def default(self, line):
        print "Unknown command: %s" % line
        print "Type `help` for commands available."

    def shell_command(self, param):
        subprocess.call(param, shell=True)

    def verbose(self, msg):
        if self.verbose_mode:
            print msg

    def register_alias(self, alias, name):
        """
        Register alias function to the method.
        Aliases are not listed by `help` command.
        """
        self.__dict__['do_' + alias] = getattr(self, name)

    def update_prompt(self):
        """
        Call this to update the shell prompt upon reconnection etc.
        """
        if not hasattr(self, 'prompt_format'):
            self.prompt = '[Jubatus:' + self.engine_name() + '<' + self.cluster + '>@' + self.host + ':' + str(self.port) + '] # '
        else:
            pass #TODO: support custom prompt format

    #################################################################
    # Built-in commands
    #################################################################
    def do_exit(self, param):
        """Syntax: exit
        Exit the shell. You can also use EOF (Ctrl-D).
        """
        print
        return True

    def do_connect(self, param):
        """Syntax: connect host port [cluster]
        Connect to the specified host, port and cluster (optional).
        """
        argv = self.argv(param, 2, 3)
        host = argv[0]
        port = argv[1]
        cluster = self.cluster
        if len(argv) == 3:
            cluster = argv[2]
        print "Connecting to <%s>@%s:%d..." % (cluster, host, int(port))
        self.disconnect()
        self.connect(host, int(port), self.cluster)
        self.update_prompt()

    def do_reconnect(self, param):
        """Syntax: reconnect
        Reconnects to the current server.
        """
        argv = self.argv(param, 0, 0)
        self.disconnect()
        self.connect(self.host, self.port, self.cluster)

    def do_verbose(self, param):
        """Syntax: verbose
        Toggles the verbose mode.
        """
        argv = self.argv(param, 0, 0)
        self.verbose_mode = not self.verbose_mode
        if self.verbose_mode:
            print "Verbose mode turned on."
        else:
            print "Verbose mode turned off."

    def help_help(self):
        """
        Help for help command.
        """
        print "Display list of commands or description of the given command"

    #################################################################
    # RPC connection handling
    #################################################################
    def connect(self, host, port, cluster):
        """
        Actually, `connect` does not start TCP connection; just create client instance for RPC call.
        """
        self.disconnect()
        self.host = host
        self.port = port
        self.cluster = cluster
        self.client = self.get_client(host, port)

    def disconnect(self):
        """
        Disconnects from the server, if connected.
        """
        if self.is_connected():
            self.client.client.close()
            self.client = None

    def is_connected(self):
        """
        `is_connected` returns True, if the client can be closed.
        The TCP connection may already be closed.
        """
        return hasattr(self, 'client') and self.client is not None

    #################################################################
    # Accessor to client classes
    #################################################################
    def get_client(self, host, port):
        """
        Get client instance for given host and port.
        """
        return self.get_class('.'.join(['jubatus', self.engine_name(), 'client', self.engine_name()]))(host, port)

    def get_types_class(self, name):
        """
        Get class for the data structure of given name.
        """
        return self.get_class('.'.join(['jubatus', self.engine_name(), 'types', name]))

    #################################################################
    # Utilities
    #################################################################
    @staticmethod
    def get_class(name):
        """
        Dynamically import and return a class of given name.
        """
        levels = name.split('.')
        (package, module, basename) = (levels[0], '.'.join(levels[:-1]), levels[-1])
        return getattr(__import__(module, fromlist=[package]), basename)

    @staticmethod
    def get_shells():
        shells = {}
        work = [JubaShell]
        while work:
            parent = work.pop()
            for child in parent.__subclasses__():
                if child not in shells.values():
                    work.append(child)
                    try:
                        name = child.engine_name()
                    except NotImplementedError: # child is an abstract class
                        continue
                    shells[name] = child
        return shells

    @staticmethod
    def argv(param, minlen, maxlen=-1):
        """
        Split arguments into array.
        Raises `ValueError` if the length condition is not satisfied.
        """
        if param is not None and param != "":
            result = shlex.split(param)
        else:
            result = []
        if len(result) < minlen:
            raise ValueError, "Too few arguments (%d requred at least)" % minlen
        if 0 <= maxlen and maxlen < len(result):
            raise ValueError, "Too much arguments (%d required at most)" % maxlen
        return result

    @staticmethod
    def is_num(string):
        return re.match('^\d*\.?\d+$', string) is not None

    @staticmethod
    def get(host, port, cluster, engine=None):
        """
        Get shell for the specified parameter.
        """
        if not engine:
            # guess the engine from get_status
            client = msgpackrpc.Client(msgpackrpc.Address(host, port))
            try:
                results = client.call('get_status', cluster)
                if len(results) == 0:
                    return None
            except msgpackrpc.error.RPCError as e:
                return None
            finally:
                client.close()
            result1 = results.popitem()[1]
            if not 'PROGNAME' in result1:
                return None
            engine = result1['PROGNAME']
            if engine.startswith('juba'):
                engine = engine[4:]
        shells = JubaShell.get_shells()
        if engine in shells.keys():
            return shells[engine](host, port, cluster)
        return GenericShell(host, port, cluster)

    @staticmethod
    def computil_argnum(text, line, begidx, endidx):
        return len(JubaShell.argv(line[0:begidx],0)) - 1

    @staticmethod
    def computil_filter(text, candidates):
        return [x for x in candidates if x.startswith(text)]

class AbstractGenericShell(JubaShell):
    """
    Generic implementation of the engine-specific shell that implements
    set_config, get_config, save, load and get_status.
    This class cannot be instantiated.

    In most cases, you should inherit this class, rather than creating
    your own one from scratch for your engine.
    """

    def do_set_config(self, param):
        """Syntax: set_config algorithm [config_or_filename]
        Set algorithm and converter configuration to server.
        """
        argv = self.argv(param, 1, 2)
        algorithm = argv[0]
        if len(argv) == 1:
            config = json.dumps(self.get_generic_config(), sort_keys=True, indent=4)
        else:
            config = argv[1]
        if not config.startswith('{'):
            # TODO
            filename = argv[1]
            raise ValueError, "loading from file (%s) is not implemented yet." % filename
        clazz = self.get_types_class('config_data')
        self.client.set_config(self.cluster, clazz(algorithm, config))
        # TODO: check retval (currently returns false)

    def complete_set_config(self, text, line, begidx, endidx):
        argnum = self.computil_argnum(text, line, begidx, endidx)
        if argnum == 0:
            return self.computil_filter(text, [
                'perceptron', 'PA', 'PA1', 'PA2', 'CW', 'AROW', 'NHERD',
                'inverted_index', 'lsh', 'minhash',
                ])

    def do_get_config(self, param):
        """Syntax: get_config
        Display algorithm and converter configuration set in server.
        """
        argv = self.argv(param, 0, 0)
        config = self.client.get_config(self.cluster)
        self.print_config(config)

    def do_save(self, param):
        """Syntax: save model_id
        Save the model.
        """
        argv = self.argv(param, 1, 1)
        model_id = argv[0]
        if not self.client.save(self.cluster, model_id):
            print "save failed."

    def do_load(self, param):
        """Syntax: load model_id
        Load the given model.
        """
        argv = self.argv(param, 1, 1)
        model_id = argv[0]
        if not self.client.load(self.cluster, model_id):
            print "load failed."

    def do_get_status(self, param):
        """Syntax: get_status
        Displays status of servers.
        """
        argv = self.argv(param, 0, 0)
        status = self.client.get_status(self.cluster)
        self.print_status(status)

    def do_show_config_example(self, param):
        """Syntax: show_config_sample
        Displays example configuration.
        """
        argv = self.argv(param, 0, 0)
        print json.dumps(self.get_generic_config(), sort_keys=True, indent=4)

    def argv2datum(self, argv):
        if len(argv) % 2 != 0:
            raise ValueError, "value for the last datum is missing"

        string_values = []
        num_values = []
        for i in range(len(argv) / 2):
            feat_key = argv[i*2]
            feat_val = argv[i*2+1]
            if self.is_num(feat_val):
                num_values.append((feat_key, float(feat_val)))
            else:
                string_values.append((feat_key, feat_val))
        return self.get_types_class('datum')(string_values, num_values)

    def get_generic_config(self):
        config_template = {
            "string_filter_types": {
                "detag": { "method": "regexp", "pattern": "<[^>]*>", "replace": "" }
            },
            "string_filter_rules": [
            ],
            "num_filter_types": {
                "add_1" : { "method": "add", "value" : "1" }
            },
            "num_filter_rules": [
            ],
            "string_types": {
                "unigram" : { "method": "ngram", "char_num": "1" },
                "bigram"  : { "method": "ngram", "char_num": "2" },
                "trigram" : { "method": "ngram", "char_num": "3" }
            },
            "string_rules": [
                { "key": "*", "type": "str", "sample_weight": "bin", "global_weight": "bin" }
            ],
            "num_types": {
            },
            "num_rules": [
                { "key": "*",  "type": "num" }
            ]
        }
        return config_template

    def print_config(self, config):
        """
        Pretty-print the config structure.
        """
        config2 = config
        if hasattr(config2, 'converter'):
            print 'converter: %s' % json.dumps(json.loads(config2.__dict__.pop('converter')), sort_keys=True, indent=4)
        for key in config2.__dict__:
            print '%s: %s' % (key, getattr(config2, key))

    def print_status(self, status):
        """
        Pretty-print the status structure.
        """
        for server_port in status:
            server_stat = status[server_port]
            print "Server %s:%s" % tuple(server_port.split('_'))
            for key in server_stat:
                print "  %s: %s" % (key, server_stat[key])

    def print_datum(self, datum):
        """
        Pretty-print the datum structure.
        """
        print json.dumps({
            "string_values" : datum.string_values,
            "num_values"    : datum.num_values,
            })

class GenericShell(AbstractGenericShell):
    """
    Shell for unknown server engines.
    """
    @staticmethod
    def engine_name():
        return 'generic'

    def get_client(self, host, port):
        return GenericShell.GenericClient(host, port)

    def get_types_class(self, name):
        if name == "config_data":
            return GenericShell.GenericTypes.config_data
        raise "Unsupported type"

    class GenericClient():
        def __init__(self, host, port):
            address = msgpackrpc.Address(host, port)
            self.client = msgpackrpc.Client(address)

        def set_config(self, name, c):
            return self.client.call('set_config', name, c)

        def get_config(self, name):
            return self.client.call('get_config', name)

        def save(self, name, model_id):
            return self.client.call('save', model_id)

        def load(self, name, model_id):
            return self.client.call('load', model_id)

        def get_status(self, name):
            return self.client.call('get_status', name)

    class GenericTypes():
        class config_data():
            def __init__(self, method, config):
                self.method = method
                self.config = config

            def to_msgpack(self):
                return (self.method, self.config)

            @staticmethod
            def from_msgpack(arg):
                return config_data(arg[0], arg[1])

class ClassifierShell(AbstractGenericShell):
    @staticmethod
    def engine_name():
        return 'classifier'

    def do_train(self, param):
        """Syntax: train label datum_key datum_value [datum_key datum_value ...]
        Trains the model with given label and datum.
        Bulk training is not supported on the command line.
        """
        argv = self.argv(param, 3)
        label = argv[0]
        d = self.argv2datum(argv[1:])
        self.verbose("train: label = %s" % label)
        self.verbose("  datum = %s" % d.__dict__)
        self.client.train(self.cluster, [(label, d)])

    def do_classify(self, param):
        """Syntax: classify datum_key datum_value [datum_key datum_value ...]
        Classify the given datum.
        Bulk classification is not supported on the command line.
        """
        argv = self.argv(param, 2)
        d = self.argv2datum(argv)
        self.verbose("classify:")
        self.verbose("  datum = %s" % d.__dict__)
        results = self.client.classify(self.cluster, [d])[0]
        for result in results:
            print "%s: %s" % (result.label, str(result.prob))

class RegressionShell(AbstractGenericShell):
    @staticmethod
    def engine_name():
        return 'regression'

    def do_train(self, param):
        """Syntax: train label datum_key datum_value [datum_key datum_value ...]
        Trains the model with given label and datum.
        Bulk training is not supported on the command line.
        """
        argv = self.argv(param, 3)
        label = float(argv[0])
        d = self.argv2datum(argv[1:])
        self.verbose("train: label = %s" % label)
        self.verbose("  datum = %s" % d.__dict__)
        self.client.train(self.cluster, [(label, d)])

    def do_estimate(self, param):
        """Syntax: estimate datum_key datum_value [datum_key datum_value ...]
        Estimate the value for the given datum.
        Bulk estimation is not supported on the command line.
        """
        argv = self.argv(param, 2)
        d = self.argv2datum(argv)
        self.verbose("estimate:")
        self.verbose("  datum = %s" % d.__dict__)
        result = self.client.estimate(self.cluster, [d])[0]
        print "%s" % str(result)

class RecommenderShell(AbstractGenericShell):
    @staticmethod
    def engine_name():
        return 'recommender'

    def do_clear_row(self, param):
        """Syntax: clear_row row_id
        Clear the specified row.
        """
        argv = self.argv(param, 1, 1)
        row_id = argv[0]
        self.client.clear(self.cluster, row_id)
        # TODO: check retval

    def do_update_row(self, param):
        """Syntax: update_row row_id datum_key datum_value [datum_key datum_value ...]
        Update or insert a new row.
        """
        argv = self.argv(param, 3)
        row_id = argv[0]
        d = self.argv2datum(argv[1:])
        self.verbose("update_row ID: %s" % row_id)
        self.verbose("  datum = %s" % d.__dict__)
        self.client.update_row(self.cluster, row_id, d)

    def do_clear(self, param):
        """Syntax: clear
        Clear the model.
        """
        argv = self.argv(param, 0, 0)
        self.client.clear(self.cluster)
        # TODO: check retval

    def do_complete_row_from_id(self, param):
        """Syntax: complete_row_from_id id
        Complete row from the given ID.
        """
        argv = self.argv(param, 1, 1)
        row_id = argv[0]
        d = self.client.complete_row_from_id(self.cluster, row_id)
        self.print_datum(d)

    def do_complete_row_from_data(self, param):
        """syntax: complete_row_from_data datum_key datum_value [datum_key datum_value ...]
        Complete row from the given datum.
        """
        argv = self.argv(param, 2)
        d = self.argv2datum(argv)
        d = self.client.complete_row_from_data(self.cluster, d)
        self.print_datum(d)

    def do_similar_row_from_id(self, param):
        """Syntax: similar_row_from_id id
        Similar row from the given ID.
        """
        argv = self.argv(param, 1, 1)
        row_id = argv[0]
        d = self.client.similar_row_from_id(self.cluster, row_id)
        self.print_datum(d)

    def do_similar_row_from_data(self, param):
        """syntax: similar_row_from_data datum_key datum_value [datum_key datum_value ...]
        Similar row from the given datum.
        """
        argv = self.argv(param, 2)
        d = self.argv2datum(argv)
        d = self.client.similar_row_from_data(self.cluster, d)
        self.print_datum(d)

    def do_decode_row(self, param):
        """Syntax: decode_row id
        Decode the row of given ID.
        """
        argv = self.argv(param, 1, 1)
        row_id = argv[0]
        d = self.client.decode_row(self.cluster, row_id)
        self.print_datum(d)

    def do_get_all_rows(self, param):
        """Syntax: get_all_rows
        Returns all rows. Note that converted rows will not be displayed.
        """
        argv = self.argv(param, 0, 0)
        rows = self.client.get_all_rows(self.cluster)
        for row in rows:
            print row

    def do_similarity(self, param):
        argv = self.argv(param, 0, 0)
        print "not implemented yet."

    def do_l2norm(self, param):
        argv = self.argv(param, 0, 0)
        print "not implemented yet."

class StatShell(AbstractGenericShell):
    @staticmethod
    def engine_name():
        return 'stat'

    def do_set_config(self, param):
        """Syntax: set_config window_size
        Set window size.
        """
        argv = self.argv(param, 1, 1)
        window_size = int(argv[0])
        clazz = self.get_types_class('config_data')
        self.client.set_config(self.cluster, clazz(window_size))

    def do_push(self, param):
        """Syntax: push key value
        Add value for the specified key.
        """
        argv = self.argv(param, 2, 2)
        key = str(argv[0])
        value = float(argv[1])
        self.client.push(self.cluster, key, value)

    def do_sum(self, param):
        """Syntax: sum key
        Get sum for the specified key.
        """
        argv = self.argv(param, 1, 1)
        key = str(argv[0])
        print self.client.sum(self.cluster, key)

    def do_stddev(self, param):
        """Syntax: stddev key
        Get stddev for the specified key.
        """
        argv = self.argv(param, 1, 1)
        key = str(argv[0])
        print self.client.stddev(self.cluster, key)

    def do_max(self, param):
        """Syntax: max key
        Get max for the specified key.
        """
        argv = self.argv(param, 1, 1)
        key = str(argv[0])
        print self.client.max(self.cluster, key)

    def do_min(self, param):
        """Syntax: min key
        Get min for the specified key.
        """
        argv = self.argv(param, 1, 1)
        key = str(argv[0])
        print self.client.min(self.cluster, key)

    def do_entropy(self, param):
        """Syntax: entropy key
        Get entropy for the specified key.
        """
        argv = self.argv(param, 1, 1)
        key = str(argv[0])
        print self.client.entropy(self.cluster, key)

    def do_moment(self, param):
        """Syntax: moment key n c
        Get n-th moment about c of values in the specified key.
        """
        argv = self.argv(param, 3, 3)
        key = str(argv[0])
        n = int(argv[1])
        c = float(argv[2])
        print self.client.moment(self.cluster, key, n, c)

class GraphShell(AbstractGenericShell):
    @staticmethod
    def engine_name():
        return 'graph'

    def do_set_config(self, param):
        """Graph does not support set_config
        """
        print "Graph does not support set_config"

    def do_get_config(self, param):
        """Graph does not support get_config
        """
        print "Graph does not support get_config"

    def do_create_node(self, param):
        """Syntax: create_node
        Create node.
        """
        argv = self.argv(param, 0, 0)
        node_id = self.client.create_node(self.cluster)
        print "%s" % node_id

    def do_remove_node(self, param):
        """Syntax: remove_node node_id
        Remove the specified node.
        """
        argv = self.argv(param, 1, 1)
        node_id = str(argv[0])
        self.client.remove_node(self.cluster, node_id)

    def do_update_node(self, param):
        """Syntax: update_node node_id [property_key property_value ...]
        Update node.
        """
        argv = self.argv(param, 1)
        node_id = argv[0]
        prop = self.argv2property(argv[1:])
        self.client.update_node(self.cluster, node_id, prop)

    def do_create_edge(self, param):
        """Syntax: create_edge from_node to_node [property_key property_value ...]
        Create edge.
        """
        argv = self.argv(param, 2)
        from_node_id = str(argv[0])
        to_node_id = str(argv[1])
        prop = self.argv2property(argv[2:])
        info = self.get_types_class('edge_info')(prop, from_node_id, to_node_id)
        self.client.create_edge(self.cluster, from_node_id, info)

    def do_update_edge(self, param):
        """Syntax: update_edge edge_id from_node to_node [property_key property_value ...]
        Update edge.
        """
        argv = self.argv(param, 3)
        edge_id = long(argv[0])
        from_node_id = str(argv[1])
        to_node_id = str(argv[2])
        prop = self.argv2property(argv[3:])
        info = self.get_types_class('edge_info')(prop, from_node_id, to_node_id)
        self.client.update_edge(self.cluster, from_node_id, edge_id, info)

    def do_remove_edge(self, param):
        """Syntax: remove_edge edge_id [from_node]
        Remove the specified edge.
        from_node is mandatory when in distributed mode.
        """
        argv = self.argv(param, 1, 2)
        edge_id = long(argv[0])
        from_node_id = ""
        if len(argv) == 2:
            from_node_id = str(argv[1])
        self.client.remove_edge(self.cluster, from_node_id, edge_id)

    def do_centrality(self, param):
        """Syntax: do_centrality node_id [type]
        Calculate centrality for the node.
        "type" is 0 (PageRank) by default.
        Currenetly, only empty query is supported.
        """
        argv = self.argv(param, 1, 2)
        node_id = str(argv[0])
        c_type = 0
        query = self.get_types_class('preset_query')([], [])
        if len(argv) == 2:
            c_type = int(argv[1])
        self.client.centrality(self.cluster, node_id, c_type, query)

    def do_add_centrality_query(self, param):
        """Syntax: add_centrality_query
        Preset centrality query.
        Currenetly, only empty query is supported.
        """
        argv = self.argv(param, 0, 0)
        query = self.get_types_class('preset_query')([], [])
        self.client.add_centrality_query(self.cluster, query)

    def do_add_shortest_path_query(self, param):
        """Syntax: add_shortest_path_query
        Preset shortest_path query.
        Currenetly, only empty query is supported.
        """
        argv = self.argv(param, 0, 0)
        query = self.get_types_class('preset_query')([], [])
        self.client.add_shortest_path_query(self.cluster, query)

    def do_remove_centrality_query(self, param):
        """Syntax: remove_centrality_query
        Remove preset centrality query.
        Currenetly, only empty query is supported.
        """
        argv = self.argv(param, 0, 0)
        query = self.get_types_class('preset_query')([], [])
        self.client.remove_centrality_query(self.cluster, query)

    def do_remove_shortest_path_query(self, param):
        """Syntax: remove_shortest_path_query
        Remove preset shortest_path query.
        Currenetly, only empty query is supported.
        """
        argv = self.argv(param, 0, 0)
        query = self.get_types_class('preset_query')([], [])
        self.client.remove_shortest_path_query(self.cluster, query)

    def do_shortest_path(self, param):
        """Syntax: shortest_path src_node dst_node [max_hop]
        Calculates the shortest path from src_node to dst_node.
        """
        argv = self.argv(param, 2, 3)
        src_node = argv[0]
        dst_node = argv[1]
        max_hop = sys.maxint
        if len(argv) == 3:
            max_hop = int(argv[2])
        query = self.get_types_class('preset_query')([], [])
        req = self.get_types_class('shortest_path_req')(src_node, dst_node, max_hop, query)
        nodes = self.client.shortest_path(self.cluster, req)
        for node in nodes:
            print node

    def do_update_index(self, param):
        """Syntax: update_index
        Updates the index.
        You cannot use this method in distributed configuration.
        """
        argv = self.argv(param, 0, 0)
        self.client.update_index(self.cluster)

    def do_clear(self, param):
        """Syntax: clear
        Clear the model.
        """
        argv = self.argv(param, 0, 0)
        self.client.clear(self.cluster)

    def do_get_node(self, param):
        """Syntax: get_node node_id
        Get node information.
        """
        argv = self.argv(param, 1, 1)
        node_id = str(argv[0])
        info = self.client.get_node(self.cluster, node_id)
        print "Properties:"
        for key in info.p:
            print "  %s: %s" % (key, info.p[key])
        print "In-Edges:"
        print "  %s" % str(info.in_edges)
        print "Out-Edges:"
        print "  %s" % str(info.out_edges)

    def do_get_edge(self, param):
        """Syntax: get_edge edge_id [from_node_id]
        Get edge information.
        from_node_id is mandatory when in distributed mode.
        """
        argv = self.argv(param, 1, 2)
        edge_id = long(argv[0])
        from_node_id = "0"
        if len(argv) == 2:
            from_node_id = str(argv[1])
        info = self.client.get_edge(self.cluster, from_node_id, edge_id)
        print "Properties:"
        for key in info.p:
            print "  %s: %s" % (key, info.p[key])
        print "Source     : %s" % str(info.src)
        print "Destination: %s" % str(info.tgt)

    def argv2property(self, argv):
        if len(argv) % 2 != 0:
            raise ValueError, "value for the last property is missing"

        prop_values = {}
        for i in range(len(argv) / 2):
            prop_values[str(argv[i*2])] = str(argv[i*2+1])
        return prop_values

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Jubatus Interactive Shell Environment', add_help=False)

    # pre-load external scripts
    parser.add_argument('--load', '-l', type=str, default=None, action="append", dest="loads")
    (args, _) = parser.parse_known_args()

    if args.loads is not None:
        for load_file in args.loads:
            execfile(load_file)

    # arguments
    parser.add_argument('--host',    '-H', type=str, default="127.0.0.1")
    parser.add_argument('--port',    '-P', type=int, default=9199)
    parser.add_argument('--cluster', '-C', type=str, default="")
    parser.add_argument('--engine',  '-e', type=str, default=None, choices=JubaShell.get_shells().keys())
    parser.add_argument('--command', '-c', type=str, default=None)
    parser.add_argument('--script',  '-f', type=str, default=None)
    parser.add_argument('--help',    '-h',           default=None, action="store_true")
    args = parser.parse_args()

    if args.help:
        parser.print_help()
        sys.exit(1)

    shell = JubaShell.get(args.host, args.port, args.cluster, args.engine)
    if not shell:
        print "Failed to detect engine."
        sys.exit(1)

    if args.script is not None:
        print "Scripting is not implemented yet." # TODO
        sys.exit(1)

    shell.start(args.command)
